<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>switch语句</title>
    <url>/2022/11/25/switch%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h1><h2 id="switch的优化方案"><a href="#switch的优化方案" class="headerlink" title="switch的优化方案"></a>switch的优化方案</h2><p>switch 的分支很少时，不会进行优化，生成的代码与 if…else 基本一样。</p>
<h3 id="case值是连续的"><a href="#case值是连续的" class="headerlink" title="case值是连续的"></a>case值是连续的</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">666</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(n % <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;case 0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;case 1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;case 2\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;case 3\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;default\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，case 的值是 0、3、1、2。虽然在代码中的位置是打乱的，但这是四个连续的数。</p>
<p>这种情况下，switch 会用一个数组来存储各个 case 分支的地址。各个 case 的值就是数组的下标，决定了每个 case 地址存储在数组中的什么位置。然后计算出 <code>n % 5</code> 的值作为下标，从数组中找到所要跳转的 case 地址。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/switch%E8%AF%AD%E5%8F%A5.assets/image-20220526003013031.png"
                      alt="image-20220526003013031"
                ></p>
<h3 id="case的值并不是完全连续的"><a href="#case的值并不是完全连续的" class="headerlink" title="case的值并不是完全连续的"></a>case的值并不是完全连续的</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">666</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(n % <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;case 0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;case 1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;case 2\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;case 3\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;default\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，case 的值并不是完全连续的，中间缺了 2 和 4。</p>
<p>在这种情况下，switch 的处理和上一个代码中的基本一样，只不过会将数组中下标为 2 和 4 的位置填上 default 分支的地址。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/switch%E8%AF%AD%E5%8F%A5.assets/image-20201118185100153.png"
                      alt="image-20201118185100153"
                ></p>
<h3 id="case的值较大"><a href="#case的值较大" class="headerlink" title="case的值较大"></a>case的值较大</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">666</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(n % <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">100</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;case 0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">101</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;case 1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">105</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;case 2\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">103</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;case 3\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;default\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码中，case 的值还是基本连续的，但是值变大了。</p>
<p>这种情况下，switch 会将各个 case 的值减去其中最小的那个 case 值（此处为减 100），得到的结果作为数组的下标，然后存储 case 的地址。在判断要执行哪个分支时也是类似的，将 switch 的值减去最小的 case 值得到数组下标，根据下标从数组中找到要跳转的分支地址。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/switch%E8%AF%AD%E5%8F%A5.assets/image-20201118185808337.png"
                      alt="image-20201118185808337"
                ></p>
<h2 id="switch和if的区别"><a href="#switch和if的区别" class="headerlink" title="switch和if的区别"></a>switch和if的区别</h2><p>if…else 越后面的分支，其执行的代价就越大。因为想要执行后面的分支，就必须先经过前面所有分支的判断语句。</p>
<p>而优化后的 switch…case 将分支地址存储在数组中，不管执行哪个分支，它都只要判断一次，然后从数组中取地址。执行所有分支的代价都是一样的。</p>
<ul>
<li>switch 的分支很少时，不会进行优化，生成的代码与 if…else 基本一样</li>
</ul>
<h2 id="case只是标号"><a href="#case只是标号" class="headerlink" title="case只是标号"></a>case只是标号</h2><p><strong>注意：在 switch 语句中 case 的作用只是一个标号</strong>。</p>
<p>即使其他的 case 分支是写在 <code>case 0:</code> 的 while 代码块中，switch 还是可以根据 <code>count % 8</code> 的结果跳转到对应的分支去执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">send2</span><span class="params">(<span class="type">char</span>* to, <span class="type">char</span>* from, <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = (count + <span class="number">7</span>) / <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">switch</span> (count % <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">while</span> (n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        *to++ = *from++;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>: *to++ = *from++;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: *to++ = *from++;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>: *to++ = *from++;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: *to++ = *from++;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: *to++ = *from++;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: *to++ = *from++;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: *to++ = *from++;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>const关键字</title>
    <url>/2022/11/24/const%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h2 id="const常量"><a href="#const常量" class="headerlink" title="const常量"></a>const常量</h2><p>在 C 语言中使用常量都是通过宏来定义的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = NUM;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但宏是有缺点的：</p>
<ul>
<li>没有类型检查</li>
<li>没有符号（无法调试）</li>
</ul>
<hr>
<p>在 C++ 中使用 <code>const</code> 修饰的变量就是常量，其一旦创建后就无法被修改。<strong>所以 const 对象必须初始化</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> n1 = <span class="number">123</span>;	<span class="comment">// 正确</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n2;		<span class="comment">// 错误，未初始化</span></span><br><span class="line"></span><br><span class="line">n1 = <span class="number">123</span>;			<span class="comment">// 错误，const 对象无法被修改</span></span><br></pre></td></tr></table></figure>

<p>编译器在对待 const 常量时，与对待宏是类似的，直接将常量的值替换到表达式中去。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">	<span class="type">const</span> <span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="number">003F</span>18C8  mov         dword ptr [n],<span class="number">64</span>h  </span><br><span class="line">	<span class="type">int</span> n1 = n + <span class="number">50</span>;</span><br><span class="line"><span class="number">003F</span>18CF  mov         dword ptr [n1],<span class="number">96</span>h  </span><br></pre></td></tr></table></figure>

<p>所以即使强行修改了 const 常量的值，对其他使用到该常量的代码也是没有影响的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	*(<span class="type">int</span>*)&amp;n = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> n1 = n + <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; n1 &lt;&lt; endl;	<span class="comment">// 输出150</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多文件共享const对象"><a href="#多文件共享const对象" class="headerlink" title="多文件共享const对象"></a>多文件共享const对象</h2><p><strong>默认状态下，const对象仅在当前文件内有效。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> g_count = <span class="number">100</span>;  <span class="comment">// 在a.cpp中定义一个全局const变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> g_count;  <span class="comment">// 在b.cpp对变量进行声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, g_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的代码在编译时会报错：b.cpp中无法解析的外部符号<code>g_count</code>。</li>
</ul>
<p>如果想要在多个文件中共享const对象，那么不管是声明还是定义都需要添加<code>extern</code>关键字。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> g_count = <span class="number">100</span>;  <span class="comment">// 在a.cpp中定义一个全局const变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> g_count;  <span class="comment">// 在b.cpp对变量进行声明</span></span><br></pre></td></tr></table></figure>

<h2 id="const修饰指针"><a href="#const修饰指针" class="headerlink" title="const修饰指针"></a>const修饰指针</h2><p><code>const</code> 在修饰指针类型时，有三种情况：</p>
<ul>
<li>指向常量类型的指针<strong>（pointer to const）</strong></li>
<li>自身是常量的指针<strong>（const pointer）</strong></li>
<li>指针本身是常量，并且指向了常量类型<strong>（const pointer to const）</strong></li>
</ul>
<h3 id="pointer-to-const"><a href="#pointer-to-const" class="headerlink" title="pointer to const"></a>pointer to const</h3><p>下面两种定义指针的方式是一样的，都是定义一个指向常量的指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* ptr1 = &amp;n1;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span>* ptr2 = &amp;n2;</span><br><span class="line"></span><br><span class="line">*ptr1 = <span class="number">1</span>;	<span class="comment">// 错误，无法通过指针修改指向的值</span></span><br><span class="line">*ptr2 = <span class="number">1</span>;	<span class="comment">// 错误，无法通过指针修改指向的值</span></span><br><span class="line"></span><br><span class="line">ptr1 = &amp;n2;	<span class="comment">// 正确，指针自身是可以被修改的</span></span><br><span class="line">ptr2 = &amp;n1;	<span class="comment">// 正确，指针自身是可以被修改的</span></span><br></pre></td></tr></table></figure>

<p><code>ptr1</code> 和 <code>ptr2</code> 都是指向常量的指针，无法通过指针来修改所指向的值。但是 <code>ptr1</code> 和 <code>ptr2</code> 自身是可以被修改的。</p>
<p>可以通过下面的图来记忆：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/const%E5%85%B3%E9%94%AE%E5%AD%97.assets/image-20201215234105828.png"
                      alt="image-20201215234105828"
                ></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/const%E5%85%B3%E9%94%AE%E5%AD%97.assets/image-20201215234201669.png"
                      alt="image-20201215234201669"
                ></p>
<h3 id="const-pointer"><a href="#const-pointer" class="headerlink" title="const pointer"></a>const pointer</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n1 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> ptr = &amp;n1;</span><br><span class="line"></span><br><span class="line">*ptr = <span class="number">100</span>;	<span class="comment">// 正确，n1的值被修改为100</span></span><br><span class="line">ptr = &amp;n2;	<span class="comment">// 错误，指针自身是常量，无法被修改</span></span><br></pre></td></tr></table></figure>

<p><code>ptr</code> 自身是常量，其指向 int 类型。所以 <code>ptr</code> 自身无法被修改，但是可以通过 <code>ptr</code> 修改其所指向的值。</p>
<p>可以通过下面的图来记忆:</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/const%E5%85%B3%E9%94%AE%E5%AD%97.assets/image-20201215234716114.png"
                      alt="image-20201215234716114"
                ></p>
<h3 id="const-pointer-to-const"><a href="#const-pointer-to-const" class="headerlink" title="const pointer to const"></a>const pointer to const</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n1 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n2 = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> ptr = &amp;n1;</span><br><span class="line"></span><br><span class="line">*ptr = <span class="number">100</span>;	<span class="comment">// 错误</span></span><br><span class="line">ptr = &amp;n2;	<span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<p><code>ptr</code> 自身是常量，且 <code>ptr</code> 所指向的也是常量。所以既不可以修改 <code>ptr</code> 自身，也不可以通过 <code>ptr</code> 来修改其所指向的值。</p>
<p>可以通过下面的图来记忆:</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/const%E5%85%B3%E9%94%AE%E5%AD%97.assets/image-20201215235028892.png"
                      alt="image-20201215235028892"
                ></p>
<h2 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h2><p>引用的类型必须与其所引用对象的类型一致，但是有两个例外情况。第一种例外情况就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = i;  <span class="comment">// 允许常量引用绑定到非常量对象</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = r1 * <span class="number">2</span>;  <span class="comment">// 正确</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r3 = r1 * <span class="number">2</span>;  <span class="comment">// 错误：r3普通引用，不能用表达式进行初始化。</span></span><br></pre></td></tr></table></figure>

<p>要理解这种例外情况的原因，就需要弄清楚当一个常量引用绑定到另外一种类型上时到底发生了什么：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ri = dval;</span><br></pre></td></tr></table></figure>

<p>编译器将上面的代码变成如下形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> temp = dval;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ri = temp;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，<code>ri</code>绑定的是一个<strong>临时对象</strong>。临时对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名对象。</p>
<p>如果<code>ri</code>不是常量引用，而是普通引用。那么就允许通过<code>ri</code>进行修改，这样就会改变<code>ri</code>所引用对象的值。而<code>ri</code>引用的是一个临时对象，这样就变成了对临时变量的修改。显然这是一种不合理的行为。</p>
<h2 id="constexpr和常量表达式"><a href="#constexpr和常量表达式" class="headerlink" title="constexpr和常量表达式"></a>constexpr和常量表达式</h2><p><strong>常量表达式（const expression）</strong>是指值不会改变并且在编译过程中就能得到计算结果的表达式。用常量表达式初始化的const对象也是常量表达式。</p>
<ul>
<li>常量折叠和常量传播</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> max_files = <span class="number">20</span>;         <span class="comment">// max_files是常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> limit = max_files + <span class="number">1</span>;  <span class="comment">// limit是常量表达式</span></span><br><span class="line"><span class="type">int</span> staff_size = <span class="number">27</span>;              <span class="comment">// staff_size不是常量表达式</span></span><br></pre></td></tr></table></figure>

<h3 id="constexpr变量"><a href="#constexpr变量" class="headerlink" title="constexpr变量"></a>constexpr变量</h3><p>C++11规定，允许将变量声明为<code>constexpr</code>类型以便由编译器来验证变量的值是否是一个常量表达式。声明为<code>constexpr</code>的变量一定是一个常量，而且必须使用常量表达式初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mf = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> limit = mf + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> sz = <span class="built_in">size</span>();    <span class="comment">// 只有当size()是一个constexpr函数时，这才是一条正确的声明语句。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果没有使用常量表达式进行初始化，编译器会报错。</li>
</ul>
<h3 id="指针和constexpr"><a href="#指针和constexpr" class="headerlink" title="指针和constexpr"></a>指针和constexpr</h3><p><code>constexpr</code>指针的初始值必须是<code>nullptr</code>或<code>0</code>，或者是存储与某个固定地址中的对象。</p>
<ul>
<li>在编译时就能确定地址的对象。比如函数名（函数地址），全局变量等。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> g_val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span>* p1 = &amp;g_val;  <span class="comment">// g_val是全局变量，在编译时就能确定地址</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">void</span>* p2 = Test;   <span class="comment">// Test是函数，函数地址也能在编译时确定</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>new和delete</title>
    <url>/2022/11/24/new%E5%92%8Cdelete/</url>
    <content><![CDATA[<h2 id="与-malloc-和-free-的区别"><a href="#与-malloc-和-free-的区别" class="headerlink" title="与 malloc 和 free 的区别"></a>与 malloc 和 free 的区别</h2><p>使用 <strong>new</strong> 创建一个类对象时，会自动调用类的构造函数。<strong>malloc</strong> 申请一个类对象的空间后，不会自动调用类的构造函数，需要手动调用。</p>
<p>类似的，<strong>delete</strong> 释放一个由 <strong>new</strong> 创建的对象时，会自动调用对象的析构函数，而 <strong>free</strong> 不会自动调用对象的析构函数。</p>
<h2 id="申请和释放数组"><a href="#申请和释放数组" class="headerlink" title="申请和释放数组"></a>申请和释放数组</h2><p>申请使用 <code>new[]</code>，释放使用 <code>delete[]</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]; <span class="comment">// 申请</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] p;  <span class="comment">// 释放</span></span><br></pre></td></tr></table></figure>

<p>在申请时还可以对数组元素进行初始化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br></pre></td></tr></table></figure>

<h3 id="带有析构函数的类对象数组"><a href="#带有析构函数的类对象数组" class="headerlink" title="带有析构函数的类对象数组"></a>带有析构函数的类对象数组</h3><p>如果 <strong>new</strong> 的数组是一个类对象数组，并且这个类写了析构函数（不是编译器默认生成的）。那么申请的堆块中就会记录下该数组的元素个数。这是为了在 <strong>delete[]</strong> 的时候可以知道一共要调用几个类对象的析构函数。</p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 构造函数</span></span><br><span class="line">	<span class="built_in">CPoint</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;CPoint::CPoint()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">CPoint</span>()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nX;</span><br><span class="line">	<span class="type">int</span> m_nY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CPoint* p = <span class="keyword">new</span> CPoint[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span>[] p;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，new 返回的地址是 <strong>0x0058AA5C</strong>。本来这个地址往上应该就是上溢标志，结果现在多了一个字段，用来存储数组元素的个数。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/new%E5%92%8Cdelete.assets/image-20201220011629462.png"
                      alt="image-20201220011629462"
                ></p>
<p>如果不使用 **delete[]**，而是使用 <strong>delete</strong> 来释放这种数组，就会出问题。</p>
<p>比如 <code>delete p</code>，p 中存的是用户可以使用的空间的地址，该地址上面还有各种堆信息，比如前后堆块的指针。这些堆信息与 p 的偏移是固定的，系统通过 <code>p + 偏移</code> 的方式获取堆信息。然而，这种数组在用户可用空间的上方还增加了一个字段，那么堆信息相对于 p 的偏移就改变了。因此，直接使用 <code>delete</code> 来释放这种数组，系统就无法正确的定位到该堆块的信息。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>友元</title>
    <url>/2022/11/24/%E5%8F%8B%E5%85%83/</url>
    <content><![CDATA[<h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><ul>
<li><p>类的友元函数可以访问类的所有成员（public，private 和 protected）。</p>
</li>
<li><p>友元函数可以在类中声明，类外实现；也可以在类中实现，类外声明。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Test1</span><span class="params">()</span></span>;  <span class="comment">// 类内声明</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Test2</span><span class="params">()</span>   <span class="comment">// 类内实现</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Base base;</span><br><span class="line">        base.m_nData = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_nData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test1</span><span class="params">()</span>  <span class="comment">// 类外实现</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base base;</span><br><span class="line">    base.m_nData = <span class="number">99</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test2</span><span class="params">()</span></span>;  <span class="comment">// 类外声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Test1</span>();</span><br><span class="line">    <span class="built_in">Test2</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>友元函数不是类的成员函数，属于全局函数。</p>
</li>
<li><p>友元函数不受访问权限的影响。在类中将友元函数的声明写在 <strong>public</strong>，<strong>private</strong> 或 <strong>protected</strong> 中都行，没有影响。</p>
</li>
</ul>
<h2 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h2><ul>
<li>友元类中所有成员都是友元。</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>函数重载、覆盖与隐藏</title>
    <url>/2022/11/24/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E3%80%81%E8%A6%86%E7%9B%96%E4%B8%8E%E9%9A%90%E8%97%8F/</url>
    <content><![CDATA[<h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><p>有时需要写一些功能相似，但参数不同的函数。C语言中通过对函数名加前缀或后缀来区分，结果函数名越加越长。C++为了解决这一问题，就提出了函数重载，<strong>允许函数具有相同的名称</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Add_int</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">Add_float</span><span class="params">(<span class="type">float</span> f1, <span class="type">float</span> f2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> f1 + f2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构成函数重载的条件"><a href="#构成函数重载的条件" class="headerlink" title="构成函数重载的条件"></a>构成函数重载的条件</h2><p>构成函数重载的条件:</p>
<ul>
<li>相同作用域</li>
<li>函数名相同</li>
<li>参数列表不同（类型不同、数量不同、顺序不同）</li>
</ul>
<p><strong>返回值类型</strong>和<strong>调用约定</strong>不同，不会构成重载。</p>
<h2 id="名称粉碎"><a href="#名称粉碎" class="headerlink" title="名称粉碎"></a>名称粉碎</h2><p>C++函数重载的本质：<strong>名称粉碎</strong></p>
<p>C 语言无法进行函数重载，就是因为 C 的名称粉碎规则太简单了，只存了函数名和调用约定。</p>
<p>名称粉碎查询工具：<strong>undname</strong></p>
<p>使用方式：<code>undname 粉碎后的名称</code></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E3%80%81%E8%A6%86%E7%9B%96%E4%B8%8E%E9%9A%90%E8%97%8F.assets/image-20220102161932665.png"
                      alt="image-20220102161932665"
                ></p>
<h2 id="函数重载的坑"><a href="#函数重载的坑" class="headerlink" title="函数重载的坑"></a>函数重载的坑</h2><h3 id="第一个坑"><a href="#第一个坑" class="headerlink" title="第一个坑"></a>第一个坑</h3><p>实参与多个重载函数的形参都可以匹配。编译器无法判断使用哪个函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Fun</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Fun</span><span class="params">(<span class="type">float</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Fun</span>(<span class="number">3.14</span>);  <span class="comment">// 报错，对重载函数的调用不明确</span></span><br><span class="line">    <span class="built_in">Fun</span>((<span class="type">int</span>)<span class="number">3.14</span>);  <span class="comment">// 正确，明确告诉编译器，调用int类型的重载函数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数的调用过程中，注意参数的完美匹配（参数类型完全匹配）。做不到完美匹配时，可以使用强转。</p>
<h3 id="第二个坑"><a href="#第二个坑" class="headerlink" title="第二个坑"></a>第二个坑</h3><p>默认实参对函数重载有影响。本质还是编译器无法判断应该调用哪个函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Test</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Test</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2 = <span class="number">5</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n1 + n2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Test</span>(<span class="number">9</span>);  <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="函数的重载、覆盖与隐藏"><a href="#函数的重载、覆盖与隐藏" class="headerlink" title="函数的重载、覆盖与隐藏"></a>函数的重载、覆盖与隐藏</h1><h2 id="函数重载-1"><a href="#函数重载-1" class="headerlink" title="函数重载"></a>函数重载</h2><p>构成函数重载的条件：</p>
<ul>
<li><p>在同作用域中。</p>
</li>
<li><p>函数名相同，参数列表不同（参数个数、参数顺序、参数类型）。</p>
</li>
<li><p>返回值和调用约定不同，不构成重载。</p>
</li>
<li><p><strong>virtual</strong> 关键字不构成重载。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;&#125;  <span class="comment">// 报错，已经定义或声明成员函数。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>成员函数用 <strong>const</strong> 修饰时，也会构成重载。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;&#125;  <span class="comment">// 正确</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span> <span class="type">const</span> </span>&#123;&#125; <span class="comment">// 正确，构成重载。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一般成员函数的 <strong>this</strong> 指针类型是 <code>type* const this</code> ，而常成员函数的 **this **指针类型是 <code>const type* const this</code>。所以两个函数的参数类型不同，就构成了重载。</p>
</li>
</ul>
<h2 id="函数覆盖（函数重写）"><a href="#函数覆盖（函数重写）" class="headerlink" title="函数覆盖（函数重写）"></a>函数覆盖（函数重写）</h2><p><strong>函数覆盖（函数重写）</strong>：子类中重写的虚函数覆盖虚表中父类虚函数的对应项。</p>
<p>构成函数重写的条件：</p>
<ul>
<li>父类函数要有 <strong>virtual</strong> 关键字修饰。</li>
<li>子类要重写的函数要与父类对应函数的函数名、调用约定、参数列表和返回值类型都一样。</li>
</ul>
<h3 id="override-关键字"><a href="#override-关键字" class="headerlink" title="override 关键字"></a>override 关键字</h3><p><strong>作用</strong>：在派生类的成员函数声明或定义中， override 确保该函数为虚函数并重写来自基类的虚函数。如果基类没有对应的虚函数，编译时会报错。</p>
<p><strong>好处</strong>：</p>
<ul>
<li>编译器可以帮你验证基类中是否由对应的虚函数。</li>
<li>增强代码可读性。告诉阅读代码的人，这是一个重写的函数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="函数隐藏"><a href="#函数隐藏" class="headerlink" title="函数隐藏"></a>函数隐藏</h2><h3 id="构成函数隐藏的条件"><a href="#构成函数隐藏的条件" class="headerlink" title="构成函数隐藏的条件"></a>构成函数隐藏的条件</h3><ul>
<li><p>如果派生类的函数与基类的函数<strong>同名</strong>,，但是<strong>参数不同</strong>。此时，<strong>不论有无 virtual 关键字</strong>， 基类的函数将被隐藏。（不要与函数重载混淆）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;A::Test()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;B::Test(int)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	B b;</span><br><span class="line">	b.<span class="built_in">Test</span>();  <span class="comment">// 报错，父类的无参函数被隐藏了。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果派生类的函数与基类的函数<strong>同名</strong>， 并且<strong>参数列表相同</strong>， 但是<strong>基类函数没有 virtual 关键字</strong>。 此时，基类的函数被隐藏。（不要与函数覆盖混淆）</p>
</li>
</ul>
<h3 id="调用被隐藏的函数"><a href="#调用被隐藏的函数" class="headerlink" title="调用被隐藏的函数"></a>调用被隐藏的函数</h3><ul>
<li><p>可以显示调用父类中被隐藏的函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;A::Test()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;B::Test(int)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	B b;</span><br><span class="line">	b.A::<span class="built_in">Test</span>();  <span class="comment">// 显示调用父类中被隐藏的函数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>我认为这与函数重载的原理是一样的。当子类实现了同名函数后，与父类函数粉碎后的名称是不同的。当通过子类对象调用同名函数时，传入的<code>this</code>指针是子类的类型，所以按照参数最优匹配原则，会调用子类中的同名函数。</p>
<p>所以当我们使用父类指针指向子类对象，再通过这个指针来调用同名函数，就可以调用到父类中的函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">B b;	</span><br><span class="line">A* p = &amp;b;</span><br><span class="line">p-&gt;<span class="built_in">Test</span>();  <span class="comment">// 调用父类中的同名函数</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>函数</title>
    <url>/2022/11/24/%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="默认实参（缺省参数）"><a href="#默认实参（缺省参数）" class="headerlink" title="默认实参（缺省参数）"></a>默认实参（缺省参数）</h2><ul>
<li><p>调用 <code>Say</code> 函数时，如果传入了第二个参数，则使用传入的参数值；如果没有传入第二个参数，则使用默认实参。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Say</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pszName, <span class="type">const</span> <span class="type">char</span>* pszContent = <span class="string">&quot;你好&quot;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; pszName &lt;&lt; <span class="string">&quot;说: &quot;</span> &lt;&lt; pszContent &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="built_in">Say</span>(<span class="string">&quot;明明&quot;</span>, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">	<span class="built_in">Say</span>(<span class="string">&quot;京东&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">明明说: Hello</span><br><span class="line">京东说: 你好</span><br></pre></td></tr></table></figure>
</li>
<li><p>当函数的声明和实现分开时，默认实参要写到函数声明中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Say</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pszName, <span class="type">const</span> <span class="type">char</span>* pszContent = <span class="string">&quot;你好&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Say</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pszName, <span class="type">const</span> <span class="type">char</span>* pszContent = <span class="string">&quot;你好&quot;</span>)</span>	<span class="comment">// 错误，重复定义了默认参数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; pszName &lt;&lt; <span class="string">&quot;说: &quot;</span> &lt;&lt; pszContent &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Say</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pszName, <span class="type">const</span> <span class="type">char</span>* pszContent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; pszName &lt;&lt; <span class="string">&quot;说: &quot;</span> &lt;&lt; pszContent &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="built_in">Say</span>(<span class="string">&quot;明明&quot;</span>, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">	<span class="built_in">Say</span>(<span class="string">&quot;京东&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为函数的一个形参赋予默认实参时，该形参右侧的所有形参都必须有默认值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误，形参b右侧的c和d没有默认值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">1</span>, <span class="type">int</span> c, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">1</span>, <span class="type">int</span> c = <span class="number">2</span>, <span class="type">int</span> d = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>局部变量不能作为默认实参。除此之外，只要表达式的类型能转换成形参所需类型，该表达式就能作为默认实参。<strong>表达式的求值过程发生在函数调用时。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_n = <span class="number">100</span>;</span><br><span class="line"><span class="type">char</span> g_ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">(<span class="type">int</span> a = fun(<span class="number">5</span>), <span class="type">int</span> b = <span class="number">100</span> + <span class="number">5</span>, <span class="type">int</span> n = g_n, <span class="type">char</span> ch = g_ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// do something...</span></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">    g_n = <span class="number">999</span>;</span><br><span class="line">	<span class="built_in">Test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">25</span><br><span class="line">105</span><br><span class="line">999</span><br><span class="line">A</span><br></pre></td></tr></table></figure>

<p>从输出结果可以看到，改变了 <code>g_n</code> 的值，Test 的默认实参的值也会变化。</p>
</li>
</ul>
<h2 id="C-调用C函数"><a href="#C-调用C函数" class="headerlink" title="C++调用C函数"></a>C++调用C函数</h2><p><code>extern &quot;C&quot; void Test();</code> 就是告诉编译器使用 C 的名称粉碎规则来寻找 <code>Test</code> 函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TestC.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Test C\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// TestCpp.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 告诉编译器，此函数使用C的名称粉碎规则</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 如果有多行内容需要使用C的名称粉碎规则，可以这样</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>复习一下函数调用的过程：</p>
<ol>
<li>参数入栈</li>
<li>返回地址入栈</li>
<li>保存栈帧</li>
<li>分配局部变量空间</li>
<li>保存寄存器环境</li>
<li>执行函数体</li>
<li>还原寄存器环境</li>
<li>释放局部变量空间</li>
<li>还原栈帧</li>
<li>返回调用点</li>
</ol>
<p>从上面函数调用的过程可以看到，函数调用时，除了执行函数体，还需要做许多的额外工作。</p>
<p>有的函数，函数体很短。函数体的执行时间还没有调用函数时其他操作所花的时间多。这种函数的执行效率就很低。所以可以将其定义成宏。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x, y) (x &gt; y ? x : y)</span></span><br></pre></td></tr></table></figure>

<p><strong>短函数</strong>：生成的代码体积小、执行效率低、方便调试。（时间换空间）</p>
<p><strong>宏</strong>：生成的代码体积大，执行效率高，不方便调试。（空间换时间）</p>
<p><strong>内联函数</strong>：既可以像函数一样调试，也可以在调用点像宏一样展开。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内联函数的声明</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内联函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意1</strong>：<strong>debug 版任何内联函数都不会展开（不进行内联）。</strong></p>
<p><strong>注意2</strong>：<strong>加了<code>inline</code>关键字并不是一定会进行内联</strong>。<code>inline</code> 关键字只是建议编译器对该函数进行内联。能不能内联成功还是要看编译器。</p>
<p><strong>注意3</strong>：内联函数的声明和实现是不能分开的（声明写在头文件，实现写在cpp文件）。<strong>内联函数的声明和实现一般都写在头文件中</strong>。</p>
<p><strong>注意4</strong>：内联函数写在头文件中，即使多个Cpp文件进行包含，也不会有重定义问题。因为<strong>编译器将内联函数限制为文件作用域内</strong>。</p>
<h3 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h3><p>内联有三种编译选项：</p>
<ul>
<li><strong>&#x2F;Ob0</strong>：所有函数都不内联。</li>
<li><strong>&#x2F;Ob1</strong>：加了 <code>inline</code> 关键字的函数会尝试进行内联。</li>
<li><strong>&#x2F;Ob2</strong>：所有的函数都尝试进行内联。</li>
</ul>
<h2 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h2><p>constexpr函数（constexpr function）是指能用于常量表达式的函数。</p>
<p>定义constexpr函数需要遵循几项约定：</p>
<ul>
<li>函数的返回值及所有形参都必须是字面值类型</li>
<li>函数体中必须有且只有一条 return 语句</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">new_sz</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> foo = <span class="built_in">new_sz</span>();  <span class="comment">// foo是一个常量表达式</span></span><br></pre></td></tr></table></figure>

<p>编译器把 constexpr 函数的调用直接替换成它的结果值。为了能在编译过程中随时展开，constexpr 函数被隐式地指定为内联函数。</p>
<p>constexpr 函数体内也可以包含其他语句，只要这些语句在程序运行时不执行任何操作。也就是说，编译器不会为这些语句生成汇编指令。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">size_t</span> <span class="title">scale</span><span class="params">(<span class="type">size_t</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">new_sz</span>() * cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当传入的参数 arg 是常量表达式时，则 scale(arg) 也是常量表达式。<ul>
<li>参数是常量表达式的话，编译器在编译期间就能计算出<code>new_sz() * cnt</code>表达式的值，所以可以直接用它的结果来替换函数调用。</li>
</ul>
</li>
</ul>
<p>如果传入的参数不是常量表达式，编译器就无法在编译时计算出函数的返回值。scale 函数也就与普通函数没有区别了。此时就无法将 scale 函数用在需要常量表达式的上下文中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> foo2 = <span class="built_in">scale</span>(argc);  <span class="comment">// 报错，scale(argc)不是一个常量表达式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>NOTE</strong>：constexpr 函数不一定返回常量表达式。</p>
</blockquote>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>命名空间</title>
    <url>/2022/11/24/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<h2 id="名字冲突问题"><a href="#名字冲突问题" class="headerlink" title="名字冲突问题"></a>名字冲突问题</h2><p>在C语言中，为了解决名字冲突问题，一般是在命名时加上前缀，比如对一个函数可以这样命名：<code>工程名_模块名_函数名</code>。然而这样会导致某些函数的名称特别长，因此在命名时不会使用<code>工程名</code>和<code>模块名</code>的全称，一般使用它们的缩写。但是这样会导致信息存在一定的丢失，一开始接触到这个项目的人就很难一眼看出函数名的意思，可读性变差了。</p>
<p>C++就使用了<strong>命名空间</strong>来解决名字冲突的问题。</p>
<p>作用域从小到大有：<strong>块作用域</strong>、<strong>函数作用域</strong>、<strong>文件作用域</strong>、<strong>全局作用域</strong>。</p>
<p><strong>命名空间</strong>相当于是在全局作用域中圈出一块，作为带有名字的作用域。</p>
<h2 id="命名空间的定义"><a href="#命名空间的定义" class="headerlink" title="命名空间的定义"></a>命名空间的定义</h2><p>只要能出现在全局作用域中的声明就能置于命名空间内。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个名为 Test 的命令空间</span></span><br><span class="line"><span class="keyword">namespace</span> Test &#123;</span><br><span class="line">    <span class="comment">// 凡是在全局作用域中能做的事，命名空间中都可以做。</span></span><br><span class="line">	<span class="type">int</span> g_nVal = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Test::Fun()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>命令空间的代码可以是不连续的</strong>，甚至可以写到不同的文件中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Test &#123;</span><br><span class="line">	<span class="type">int</span> g_nVal = <span class="number">99</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">namespace</span> Test &#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Test::Fun()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用命名空间中的成员"><a href="#使用命名空间中的成员" class="headerlink" title="使用命名空间中的成员"></a>使用命名空间中的成员</h2><h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><p>通过 <code>using namespace 命名空间名称</code> 来引入命名空间中的所有成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Test &#123;</span><br><span class="line">	<span class="type">int</span> g_nVal = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Test::Fun()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	g_nVal = <span class="number">100</span>;</span><br><span class="line">	<span class="built_in">Fun</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>using namespace 命名空间名称</code> 会将命名空间中的所有成员都引入<strong>当前作用域</strong>。比如下面的代码，<code>using namespace Test</code> 是在块作用域中，所以只是将<code>Test</code>中的成员引入块作用域中，并没有引入 main 函数的作用域。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Test &#123;</span><br><span class="line">	<span class="type">int</span> g_nVal = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Test::Fun()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">using</span> <span class="keyword">namespace</span> Test;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	g_nVal = <span class="number">100</span>;	<span class="comment">// 报错，未定义的标识符</span></span><br><span class="line">	<span class="built_in">Fun</span>();			<span class="comment">// 报错，未定义的标识符</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用这种方法要小心。<strong>如果多个命名空间中存在同名的成员，在使用时要指明属于哪一个命名空间。否则的话，编译器无法判断该其属于哪一个命名空间。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Test1 &#123;</span><br><span class="line">	<span class="type">int</span> g_nVal = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Test2 &#123;</span><br><span class="line">	<span class="type">int</span> g_nVal = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Test1;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Test2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	g_nVal = <span class="number">666</span>;	<span class="comment">// 报错，不明确的符号。编译器无法判断这是哪一个命名空间的成员</span></span><br><span class="line">    Test1::g_nVal = <span class="number">666</span>;	<span class="comment">// 正确，指明了是哪一个命名空间中的成员</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><p>通过 <code>using 命名空间名称::成员名</code> 来引入特定的成员。与第一种方法类似，这种方法也是将成员<strong>引入到当前作用域</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Test &#123;</span><br><span class="line">	<span class="type">int</span> g_nVal = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Test::Fun()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> Test::g_nVal;</span><br><span class="line">	<span class="keyword">using</span> Test::Fun;</span><br><span class="line"></span><br><span class="line">	g_nVal = <span class="number">100</span>;</span><br><span class="line">	<span class="built_in">Fun</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第三种方法"><a href="#第三种方法" class="headerlink" title="第三种方法"></a>第三种方法</h3><p>直接通过 <code>命名空间名称::成员名</code> 这种形式来使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Test &#123;</span><br><span class="line">	<span class="type">int</span> g_nVal = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Test::Fun()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Test::g_nVal = <span class="number">100</span>;</span><br><span class="line">	Test::<span class="built_in">Fun</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为命名空间取别名"><a href="#为命名空间取别名" class="headerlink" title="为命名空间取别名"></a>为命名空间取别名</h2><p>使用 <code>namespace 别名 = 命名空间名;</code> 来为一个命名空间取别名。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Test &#123;</span><br><span class="line">	<span class="type">int</span> g_nVal = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> TestXXX = Test;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TestXXX::g_nVal = <span class="number">666</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>多态与虚函数</title>
    <url>/2022/11/24/%E5%A4%9A%E6%80%81%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态性 (polymorphism) 可以简单地概括为“一个接口，多种方法”，它是面向对象编程领域的核心概念。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。</p>
<p>C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</p>
<p>C++ 分为静态多态和动态多态：</p>
<ul>
<li><p><strong>编译时多态性（静态多态）</strong>：</p>
</li>
<li><p><strong>运行时多态性（动态多态）</strong>：通过<strong>虚函数</strong>实现</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CAnimal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;吃东西&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CCat</span> :<span class="keyword">public</span> CAnimal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;吃鱼&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CDog</span> :<span class="keyword">public</span> CAnimal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;吃骨头&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CCat cat;</span><br><span class="line">    CDog dog;</span><br><span class="line"></span><br><span class="line">    CAnimal* p = &amp;cat;</span><br><span class="line">    p-&gt;<span class="built_in">Eat</span>();  <span class="comment">// 吃鱼</span></span><br><span class="line"></span><br><span class="line">    p = &amp;dog;</span><br><span class="line">    p-&gt;<span class="built_in">Eat</span>(); <span class="comment">// 吃骨头</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>虚函数的语法：</p>
<ul>
<li>父类和子类有着共同的函数声明。</li>
<li>父类函数必须有<code>virtual</code>关键字，子类函数可以没有。</li>
<li>必须使用父类的指针或者引用来调用子类对象，才有多态效果。</li>
</ul>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CAnimal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 父类中的虚函数必须加virtual关键字</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Eat</span><span class="params">()</span>  <span class="comment">// 父类和子类有着共同的函数声明</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;吃东西&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CCat</span> :<span class="keyword">public</span> CAnimal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 子类中的函数可以不加virtual关键字</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Eat</span><span class="params">()</span> <span class="comment">// 父类和子类有着共同的函数声明</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;吃鱼&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CDog</span> :<span class="keyword">public</span> CAnimal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 子类中的函数可以不加virtual关键字</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Eat</span><span class="params">()</span> <span class="comment">// 父类和子类有着共同的函数声明</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;吃骨头&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CCat cat;</span><br><span class="line">    CDog dog;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须通过父类的指针或引用来调用子类对象的函数</span></span><br><span class="line">    CAnimal* p = &amp;cat;  <span class="comment">// 通过父类指针</span></span><br><span class="line">    p-&gt;<span class="built_in">Eat</span>();  <span class="comment">// 吃鱼</span></span><br><span class="line"></span><br><span class="line">    p = &amp;dog;</span><br><span class="line">    p-&gt;<span class="built_in">Eat</span>(); <span class="comment">// 吃骨头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须通过父类的指针或引用来调用子类对象的函数</span></span><br><span class="line">    CAnimal&amp; ref1 = cat;  <span class="comment">// 通过父类引用</span></span><br><span class="line">    ref1.<span class="built_in">Eat</span>();  <span class="comment">// 吃鱼</span></span><br><span class="line"></span><br><span class="line">    CAnimal&amp; ref2 = dog;  <span class="comment">// 通过父类引用</span></span><br><span class="line">    ref2.<span class="built_in">Eat</span>();  <span class="comment">// 吃骨头</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="虚表指针和虚表"><a href="#虚表指针和虚表" class="headerlink" title="虚表指针和虚表"></a>虚表指针和虚表</h3><p><strong>虚函数</strong>是通过<strong>虚表指针（__vfptr）</strong>和<strong>虚表（vftable）</strong>来实现的。</p>
<p>当类中存在虚函数时，类对象中将会多出一个<strong>虚表指针（__vfptr）</strong>成员。该成员中存储的是这个类所对应的<strong>虚表（vftable）</strong>的地址。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/%E5%A4%9A%E6%80%81%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0.assets/image-20220820235822484.png"
                      alt="image-20220820235822484"
                ></p>
<p>每个类所对应的虚表中存储着该类中所有虚函数的地址（包括从父类继承的），相当于一个函数指针数组。当类对象要调用虚函数时，就会根据虚表指针找到虚表，再从虚表中获取对应的虚函数地址来调用。</p>
<hr>
<p><strong>虚表的一些特性</strong>：</p>
<ul>
<li><p>虚表中没有记录边界。一般情况下，查询虚表的代码在编译时就确定了，编译器自己计算偏移，所以不会溢出。</p>
</li>
<li><p>一个单独的类，不管有没有继承，有没有派生，只要有虚函数，就会有虚表。</p>
</li>
<li><p>虚表所在的内存是只读数据区，一般情况下，无法进行修改。</p>
</li>
<li><p>在底层的实现中，构造和析构时调用虚函数，并不会通过虚表来调用，而是像普通成员函数一样，直接进行调用。</p>
<p>以构造函数为例，下面的代码中，B的构造函数中调用<code>Test</code>时，是直接执行<code>call B::Test</code>的，而不是通过虚表来调用。如果子类没有重写父类的虚函数，那么在调用<code>Test</code>时，就是直接调用父类的函数，即：<code>call A::Test</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;A::Test&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;B::Test&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">B</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">Test</span>();  <span class="comment">// 执行 call B::Test，不通过虚表调用</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="虚表的构造时机"><a href="#虚表的构造时机" class="headerlink" title="虚表的构造时机"></a>虚表的构造时机</h3><p><strong>类的虚表是在编译时构造的。</strong>构造的大概过程如下：</p>
<ol>
<li>构造父类的虚表。</li>
<li>子类直接将父类的虚表拷贝一份，作为自己的虚表。此时虚表中的地址，都是父类中虚函数的地址。</li>
<li>如果子类对父类中的虚函数进行了重写，就将重写的函数地址覆盖掉虚表中的对应项。</li>
<li>在子类虚表中添加子类自己独有的虚函数地址。</li>
</ol>
<h3 id="初始化虚表指针的时机"><a href="#初始化虚表指针的时机" class="headerlink" title="初始化虚表指针的时机"></a>初始化虚表指针的时机</h3><p><strong>类对象的虚表指针是在构造函数执行时进行初始化的。</strong></p>
<p>创建一个子类对象时，初始化虚表指针的大概过程：</p>
<ol>
<li>先执行父类的构造函数，虚表指针被初始化为父类的虚表地址。</li>
<li>执行子类自身的构造函数，虚表指针被修改为子类的虚表地址。</li>
</ol>
<h3 id="虚函数的调用过程"><a href="#虚函数的调用过程" class="headerlink" title="虚函数的调用过程"></a>虚函数的调用过程</h3><p>通过父类指针（或引用）调用虚函数的过程：</p>
<ol>
<li>父类指针（或引用）指向子类对象。</li>
<li>通过父类指针（或引用）获取<strong>虚表指针（__vfptr）</strong></li>
<li>通过<strong>虚表指针（__vfptr）</strong>找到<strong>虚表（vftable）</strong><ul>
<li>子类对象中的虚表指针指向的是子类虚表</li>
</ul>
</li>
<li>从<strong>虚表（vftable）</strong>获取对应虚函数的地址并调用。<ul>
<li>由于已经使用子类中重写的函数地址覆盖掉了虚表中父类原本的函数地址。所以父类在调用虚函数时，调用的子类中重写后的函数。</li>
</ul>
</li>
</ol>
<h2 id="什么时候有多态效果"><a href="#什么时候有多态效果" class="headerlink" title="什么时候有多态效果"></a>什么时候有多态效果</h2><ul>
<li><p><strong>一般的成员函数中调用虚函数，有多态效果（对象是哪个类的，就调用哪个类的虚函数）。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">VirtualFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Parent::VirtualFunc()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">VirtualFunc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> :<span class="keyword">public</span> Parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">VirtualFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Child::VirtualFunc()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parent* p = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    p = <span class="keyword">new</span> Child;</span><br><span class="line">    p-&gt;<span class="built_in">Test</span>();  <span class="comment">// 调用子类中实现的VirtualFunc函数</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">    p = <span class="keyword">new</span> Parent;</span><br><span class="line">    p-&gt;<span class="built_in">Test</span>();  <span class="comment">// 调用父类中实现的VirtualFunc函数</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用虚函数时，是根据类对象中的虚表指针来找到虚函数地址并调用的。子类对象在创建时就已经替换掉了虚表，所以通过子类对象只能调用到子类重写后的虚函数。</p>
<p><code>Test()</code>函数中调用<code>VirtualFunc()</code>时，是通过对象的 this 指针来调用的。先通过 this 指针找到类对象中的虚表指针，而这个虚表指针存储的是该类的虚表。所以当对象是哪个类的，就会调用哪个类的虚函数。</p>
</li>
<li><p><strong>构造函数中调用虚函数，没有多态效果。</strong></p>
<p>下面的代码中，B的构造函数中调用<code>Test</code>时，是直接执行<code>call B::Test</code>的，而不是通过虚表来调用。如果子类没有重写父类的虚函数，那么在调用<code>Test</code>时，就是直接调用父类的函数，即：<code>call A::Test</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;A::Test&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;B::Test&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">B</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">Test</span>();  <span class="comment">// 执行 call B::Test，不通过虚表调用</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>析构函数中调用虚函数，没有多态效果（析构会回填虚表指针）。</strong></p>
<p>析构的时候，虚表指针会被修改为析构函数所属的类的虚表。子类的析构早于父类。在执行父类析构时，子类中的资源都已经释放了，如果此时调用的虚函数还是子类实现的虚函数，那就会产生问题。所以在执行析构函数时，要修改虚表指针指向当前类的虚表。</p>
</li>
<li><p><strong>构造函数不能是虚函数，析构函数一般都是虚函数。</strong></p>
</li>
</ul>
<h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><p><strong>使用多态时，析构函数一般都写成虚函数。</strong></p>
<p><strong>如果父类的析构函数是虚函数，那么所有子类的析构函数都是虚函数。</strong></p>
<p>这就和普通的虚函数成员是一样的，子类会继承父类中的虚函数。只不过普通虚函数在子类和父类中的名字是一样的，而虚析构函数名字不一样而已。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Parent</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Parent::~Parent()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> :<span class="keyword">public</span> Parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Child</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Child::~Child()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 当使用父类指针指向new出来的子类对象时，进行delete操作只会调用父类的析构函数</span></span><br><span class="line">    Parent* pChild = <span class="keyword">new</span> Child;</span><br><span class="line">    <span class="keyword">delete</span> pChild; <span class="comment">// 只会调用父类的析构函数，不会调用子类的析构函数。</span></span><br><span class="line"></span><br><span class="line">    Parent* pParent = <span class="keyword">new</span> Parent;</span><br><span class="line">    <span class="keyword">delete</span> pParent; <span class="comment">// 会调用父类的析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，析构函数不是虚函数。<strong>当使用父类指针指向 new 出来的子类对象时，进行 delete 操作只会调用父类的析构函数，没有调用子类的析构函数。</strong>只有将析构函数写成虚函数，在释放<code>pChild</code>时才会正确的调用子类和父类的析构函数。</p>
<p><strong>原因</strong>：</p>
<ul>
<li><p>因为析构函数不是虚函数，所以父类指针只能调用父类自身的函数，无法找到子类的析构函数。</p>
</li>
<li><p>如果析构函数是虚函数的话。按照构造虚表的过程，构造<code>Child</code>的虚表时，先拷贝<code>Parent</code>的虚表，然后用<code>Child::~Child()</code>的地址覆盖掉虚表中<code>Parent::~Parent()</code>的地址。</p>
</li>
<li><p>所以在<code>delete pChild;</code>时，因为对象是<code>Child</code>类的对象，在调用析构函数时，根据虚表就会调用<code>Child</code>的析构函数，然后由<code>Child</code>的析构函数调用<code>Parent</code>的析构函数。</p>
</li>
</ul>
<h2 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h2><ul>
<li><p>虚函数后面加上<code>=0</code>就是纯虚函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Eat</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>析构函数是纯虚函数的话，必须为其定义函数体。</p>
<ul>
<li>可以为纯虚函数提供定义，不过函数体必须定义在类的外部。</li>
</ul>
</li>
<li><p>含有纯虚函数的类叫作抽象类。如果子类继承了父类的纯虚函数，但是没有覆盖（重写），那么子类也是抽象类。</p>
</li>
<li><p>抽象类中也可以有普通的成员变量和成员函数。</p>
</li>
<li><p>抽象类无法实例化对象。</p>
</li>
<li><p>抽象类是用来定义接口的（规范化接口），后续的子孙类可以覆盖这些接口。</p>
</li>
</ul>
<h3 id="纯虚析构函数"><a href="#纯虚析构函数" class="headerlink" title="纯虚析构函数"></a>纯虚析构函数</h3><p><strong>当构函数是纯虚函数时，必须为其提供一个函数体。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~<span class="built_in">Derive</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derive derive;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码在编译时会产生一个链接错误，编译器无法找到<code>~Base</code>函数。因为在继承关系中，子类的析构函数中会调用父类的析构函数，而父类的<code>~Base</code>是一个纯虚函数，没有函数实现。这就导致了错误的产生。</p>
<p>纯虚函数也是可以定义函数体的，但是必须定义在类的外部。为上面的<code>~Base</code>函数实现函数体，这样就不会产生链接错误。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Base::~<span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为纯虚函数提供定义"><a href="#为纯虚函数提供定义" class="headerlink" title="为纯虚函数提供定义"></a>为纯虚函数提供定义</h3><p>通常的纯虚函数不需要函数体，是因为我们一般不会调用抽象类的这个函数，只会调用派生类的对应函数。但我们是可以为纯虚函数提供定义的，不过函数体必须定义在类的外部。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>  <span class="comment">//abstract class</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">virtual</span> ~<span class="built_in">Base</span>()&#123;&#125;;  <span class="comment">// 普通虚函数</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Hiberarchy</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;  <span class="comment">//纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Base::Hiberarchy</span><span class="params">()</span> <span class="type">const</span> <span class="comment">//为虚函数提供函数体</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   std::cout &lt;&lt;<span class="string">&quot;Base::Hiberarchy&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Derived</span>()&#123;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Hiberarchy</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       CB::<span class="built_in">Hiberarchy</span>();  <span class="comment">//调用父类的纯虚函数</span></span><br><span class="line">       std::cout &lt;&lt;<span class="string">&quot;Derived::Hiberarchy&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Base* pb=<span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">   pb-&gt;<span class="built_in">Hiberarchy</span>();</span><br><span class="line">   pb-&gt;Base::<span class="built_in">Hiberarchy</span>();  <span class="comment">//调用父类的纯虚函数</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>父类的虚函数如果用<code>final</code>关键字进行修饰，那么子类就无法对这个虚函数进行重写。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Test</span><span class="params">()</span> <span class="keyword">final</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 报错,无法重写 final 函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>处理类型</title>
    <url>/2022/11/24/%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="类型别名（type-alias）"><a href="#类型别名（type-alias）" class="headerlink" title="类型别名（type alias）"></a>类型别名（type alias）</h2><p>由两种方法可以定义类型别名。传统的方法是使用<code>typedef</code>关键字。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> wages;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">int</span> CINT;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125; MY_STRUCT;</span><br></pre></td></tr></table></figure>

<p>C++11标准规定了一种新的方法，使用<strong>别名声明（alias declaration）</strong>来定义类型的别名：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> CINT = <span class="type">const</span> <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_item</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> SI = Sales_item;</span><br></pre></td></tr></table></figure>

<ul>
<li>别名只在当前作用域内生效</li>
</ul>
<h3 id="别名的错误理解"><a href="#别名的错误理解" class="headerlink" title="别名的错误理解"></a>别名的错误理解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">using</span> pint = <span class="type">int</span>*;</span><br><span class="line"><span class="type">const</span> pint p = &amp;x;</span><br></pre></td></tr></table></figure>

<p>遇到一条使用了类型别名的声明语句时，人们往往会错误地尝试把类型别名替换成它本来的样子，以理解该语句的含义。比如下面这样，很多人会将第一条语句错误的理解为第二条语句。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> pint p = &amp;x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p = &amp;x;  <span class="comment">//注意：这是对上一条语句的错误理解</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>const pint p</code>：其中<strong>const</strong>是修饰<strong>p</strong>的，相当于<code>int* const p</code>。p是一个指向int的指针常量。</li>
<li><code>const int* p</code>：其中的const是修饰int的，p是一个指向const int的常量指针。</li>
</ul>
<h2 id="auto-类型占位符（类型说明符）"><a href="#auto-类型占位符（类型说明符）" class="headerlink" title="auto 类型占位符（类型说明符）"></a>auto 类型占位符（类型说明符）</h2><p>变量的类型过于复杂或无法确定表达式的类型时，就可以使用类型占位符<code>auto</code>来定义。</p>
<p><code>auto</code> 让编译器通过初始值来推算变量的类型，所以 <code>auto</code> 定义的变量必须有初始值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> n = <span class="number">3</span>; <span class="comment">//3是int类型,所以推断出n是int类型</span></span><br><span class="line"><span class="keyword">auto</span> p = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">p = <span class="number">55</span>; <span class="comment">//报错, p是const char*类型,不能赋值int类型的值</span></span><br><span class="line"><span class="keyword">auto</span> z; <span class="comment">//报错, 没有初始值，无法推断z的类型</span></span><br></pre></td></tr></table></figure>

<p>若使用 <code>auto</code> 在一条语句中声明多个变量，那么该语句中所有变量的初始基本数据类型都必须一样。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span>, *p = &amp;i;	<span class="comment">// 正确：i是整型，p是整型指针</span></span><br><span class="line"><span class="keyword">auto</span> sz = <span class="number">0</span>, pi = <span class="number">3.14</span>;	<span class="comment">// 错误：sz和pi的类型不一样</span></span><br></pre></td></tr></table></figure>

<p>如果使用数组名作为 auto 变量的初始值，推断得到的类型是指针，而不是数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> i = arr;  <span class="comment">// i是int*类型，而不是int [4]类型。相当于：auto i = &amp;arr[0];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用可以正常使用</span></span><br><span class="line"><span class="keyword">auto</span>&amp; r = arr;  <span class="comment">// r是arr的引用，也是数组类型。</span></span><br></pre></td></tr></table></figure>

<h3 id="常量和auto"><a href="#常量和auto" class="headerlink" title="常量和auto"></a>常量和auto</h3><p>auto 一般会忽略掉初始值的顶层 const，而底层 cosnt 则会保留下来。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i;  <span class="comment">// 自身是常量，顶层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *cp = &amp;i;  <span class="comment">// 指向常量，底层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> ccp = &amp;i;  <span class="comment">// 靠左的是底层const，靠右的是顶层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;cr = ci;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> a = ci;   <span class="comment">// a是一个int类型（ci的顶层const特性被忽略了）</span></span><br><span class="line"><span class="keyword">auto</span> b = cp;   <span class="comment">// b是const int*类型（cp的底层const保留下来）</span></span><br><span class="line"><span class="keyword">auto</span> c = cr;   <span class="comment">// c是一个int类型（cr是ci的别名，ci本身是一个顶层const）</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i;   <span class="comment">// d是int*类型</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci;  <span class="comment">// e是一个指向int常量的指针（&amp;ci是一个指向常量的指针，属于底层const）</span></span><br><span class="line"><span class="keyword">auto</span> f = ccp;  <span class="comment">// f是const int*类型（靠右的顶层const被忽略了）</span></span><br></pre></td></tr></table></figure>

<p>如果希望推断出的 auto 类型是一个顶层 const（自身是常量），需要明确指出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span> x = ci;  <span class="comment">// x是const int类型</span></span><br></pre></td></tr></table></figure>

<p>还可以将引用的类型设为 auto，此时原来的引用初始化规则任然适用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;g = ci;         <span class="comment">// g是一个整型常量引用</span></span><br><span class="line"><span class="keyword">auto</span> &amp;h = <span class="number">42</span>;         <span class="comment">// 错误：不能为非常量引用绑定字面值</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> &amp;j = <span class="number">42</span>;   <span class="comment">// 正确：常量引用可以绑定字面值</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>设置一个类型为 auto 的引用时，初始值中的顶层 const 特性仍然保留。</strong></li>
</ul>
<h2 id="decltype-类型指示符"><a href="#decltype-类型指示符" class="headerlink" title="decltype 类型指示符"></a>decltype 类型指示符</h2><p><code>decltype</code> 的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，<strong>却不实际计算表达式的值</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">6</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f</span>()) n = <span class="number">1</span>;	<span class="comment">// n的类型是函数f的返回类型，即n为int型。</span></span><br><span class="line"><span class="comment">// 编译器并不实际调用函数f，只是分析表达式 f() 的最终类型是什么。</span></span><br></pre></td></tr></table></figure>

<p>对于引用类型，decltype得到的还是引用类型，而不是所引用的对象的类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>&amp; r = i;</span><br><span class="line"><span class="type">int</span>* p = &amp;i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(r) x;   <span class="comment">// 错误：r是引用类型int&amp;，所以x也是引用类型。引用类型必须初始化。</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) y;  <span class="comment">// 错误：指针解引用后得到的是引用类型int&amp;，所以必须初始化。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果想通过引用得到目标对象的类型，可以把引用作为表达式的一部分</span></span><br><span class="line"><span class="keyword">decltype</span>(r+<span class="number">0</span>) x;  <span class="comment">// 正确：加法的结果是int，所以x是int类型。</span></span><br></pre></td></tr></table></figure>

<p>对于数组类型，与 auto 不同，decltype得到的还是数组类型，而不是指针类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">decltype</span>(arr) i;  <span class="comment">// i的类型是int [4]</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：对于decltype所用的表达式来说，如果变量名加上括号，则得到的类型与不加括号时会有不同。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>((i)) x;  <span class="comment">// 错误：x是引用类型int&amp;，必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(i) x;    <span class="comment">// x是int类型</span></span><br></pre></td></tr></table></figure>

<ul>
<li>变量是一种可以作为语句左值的特殊表达式，所以这样的decltype就会得到引用类型。</li>
</ul>
<blockquote>
<p>切记：<code>decltype((variable))</code>的结果永远是引用，而<code>decltype(variable)</code>的结果只有当<code>variable</code>本身是引用时才是引用。</p>
</blockquote>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>异常处理</title>
    <url>/2022/11/24/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="常见的错误处理方式"><a href="#常见的错误处理方式" class="headerlink" title="常见的错误处理方式"></a>常见的错误处理方式</h2><ol>
<li><p><strong>函数的结果通过参数传出，返回值用来返回错误或成功信息。</strong></p>
<p>可以定义一些表示信息的宏：</p>
<ul>
<li><code>#define EXE_OK 0x1</code></li>
<li><code>#define EXE_ADD_OVERFLOW 0x2</code></li>
<li><code>#define EXE_SUB_OVERFLOW 0x3</code></li>
<li>…</li>
</ul>
</li>
<li><p><strong>全局错误码</strong></p>
<p>有一个全局变量来记录当前程序所执行的上一个函数的错误或成功信息。类似于使用<code>GetLastError</code>来获取错误信息。</p>
<p>与上面一样，可以定义一些宏用来表示错误信息，增加可读性。</p>
</li>
</ol>
<h2 id="使用异常来处理错误"><a href="#使用异常来处理错误" class="headerlink" title="使用异常来处理错误"></a>使用异常来处理错误</h2><ul>
<li><p>出现错误的函数：使用<code>throw</code>关键字来抛出错误</p>
</li>
<li><p>处理错误的函数：使用<code>try和catch</code>关键字来接收错误</p>
</li>
</ul>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nRet = n1 + n2;</span><br><span class="line">    <span class="keyword">if</span> (n1 &gt; <span class="number">0</span> &amp;&amp; n2 &gt; <span class="number">0</span> &amp;&amp; nRet &lt; <span class="number">0</span>) <span class="comment">//两个正数相加，结果为负，则溢出</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">1</span>; <span class="comment">//加法溢出，抛出错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dec</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nRet = n1 - n2;</span><br><span class="line">    <span class="keyword">if</span> (n1 &gt; <span class="number">0</span> &amp;&amp; n2 &lt; <span class="number">0</span> &amp;&amp; nRet &lt; <span class="number">0</span>) <span class="comment">//正数减负数，结果为负，则溢出</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">2</span>; <span class="comment">//减法溢出，抛出错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Add</span>(n1, n2);</span><br><span class="line">    <span class="built_in">Dec</span>(n1, n2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Foo</span>(<span class="number">0x7fffffff</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">int</span> nErr)  <span class="comment">// 接收错误</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (nErr)  <span class="comment">// 判断错误类型</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;加法溢出&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;减法溢出&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="不处理抛出的异常"><a href="#不处理抛出的异常" class="headerlink" title="不处理抛出的异常"></a>不处理抛出的异常</h2><p>如果程序使用 <code>throw</code> 抛出错误，但是没有使用 <code>try/catch</code> 来进行处理。这种情况下，产生错误触发异常时，程序会调用 <code>abort</code> 函数（debug版有，release版没有）来进行弹窗提示，然后退出程序。</p>
<p>在 <strong>debug</strong> 版中，如果没有产生错误，程序还是会正常运行。如果产生了错误，触发异常，就会弹出一个下面这样的窗口。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.assets/image-20210110231415282.png"
                      alt="image-20210110231415282"
                ></p>
<p>在 <strong>release</strong> 版中，如果没有产生错误，程序还是会正常运行。如果产生了错误，触发异常，程序不会弹窗提示，而是直接退出。</p>
<p>示例代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nRet = n1 + n2;</span><br><span class="line">    <span class="keyword">if</span> (n1 &gt; <span class="number">0</span> &amp;&amp; n2 &gt; <span class="number">0</span> &amp;&amp; nRet &lt; <span class="number">0</span>) <span class="comment">//两个正数相加，结果为负，则溢出</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">1</span>; <span class="comment">//加法溢出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dec</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nRet = n1 - n2;</span><br><span class="line">    <span class="keyword">if</span> (n1 &gt; <span class="number">0</span> &amp;&amp; n2 &lt; <span class="number">0</span> &amp;&amp; nRet &lt; <span class="number">0</span>) <span class="comment">//正数减负数，结果为负，则溢出</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">2</span>; <span class="comment">//减法溢出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Add</span>(n1, n2);</span><br><span class="line">    <span class="built_in">Dec</span>(n1, n2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Foo</span>(<span class="number">0x7fffffff</span>, <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;123&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="抛出的错误可以是任何类型"><a href="#抛出的错误可以是任何类型" class="headerlink" title="抛出的错误可以是任何类型"></a>抛出的错误可以是任何类型</h2><ul>
<li><p>使用 <code>throw</code> 抛出错误时，不是只能抛出整型的，还可以抛出其他类型的错误。</p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nRet = n1 + n2;</span><br><span class="line">    <span class="keyword">if</span> (n1 &gt; <span class="number">0</span> &amp;&amp; n2 &gt; <span class="number">0</span> &amp;&amp; nRet &lt; <span class="number">0</span>) <span class="comment">//两个正数相加，结果为负，则溢出</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">A</span>(); <span class="comment">//加法溢出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dec</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nRet = n1 - n2;</span><br><span class="line">    <span class="keyword">if</span> (n1 &gt; <span class="number">0</span> &amp;&amp; n2 &lt; <span class="number">0</span> &amp;&amp; nRet &lt; <span class="number">0</span>) <span class="comment">//正数减负数，结果为负，则溢出</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">2</span>; <span class="comment">//减法溢出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Add</span>(<span class="number">0x7fffffff</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (A a)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;加法溢出&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">int</span> nErr)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;减法溢出&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>throw</code>抛出的错误类型和使用<code>catch</code>接收的错误类型，必须严格匹配，不会进行隐式转换。</p>
<p>下面的代码运行后会调用 <code>abort</code> 函数。</p>
<p><code>Add</code>函数抛出一个 float 类型的错误，但是 main 函数中并没有使用 <code>catch</code> 接收 float 类型的错误，这就相当于没有对 <code>Add</code> 中的错误进行处理。所以产生错误时，会直接调用 <code>abort</code> 函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nRet = n1 + n2;</span><br><span class="line">    <span class="keyword">if</span> (n1 &gt; <span class="number">0</span> &amp;&amp; n2 &gt; <span class="number">0</span> &amp;&amp; nRet &lt; <span class="number">0</span>) <span class="comment">//两个正数相加，结果为负，则溢出</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">3.14f</span>; <span class="comment">//抛出一个float类型的错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dec</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nRet = n1 - n2;</span><br><span class="line">    <span class="keyword">if</span> (n1 &gt; <span class="number">0</span> &amp;&amp; n2 &lt; <span class="number">0</span> &amp;&amp; nRet &lt; <span class="number">0</span>) <span class="comment">//正数减负数，结果为负，则溢出</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">2</span>; <span class="comment">//减法溢出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Add</span>(<span class="number">0x7fffffff</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">double</span> dblErr)  </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;加法溢出&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">int</span> nErr)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;减法溢出&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="触发异常会调用析构"><a href="#触发异常会调用析构" class="headerlink" title="触发异常会调用析构"></a>触发异常会调用析构</h2><p>在触发异常时，程序会自动调用 <code>throw</code> 代码之前的所有局部对象的析构函数，将它们进行销毁。</p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CFoo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CFoo</span>() &#123; cout &lt;&lt; <span class="string">&quot;CFoo()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">CFoo</span>() &#123; cout &lt;&lt; <span class="string">&quot;~CFoo()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> </span><br><span class="line">    &#123;</span><br><span class="line">        CFoo foo;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">int</span> nErr)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CFoo</span>()</span><br><span class="line">~<span class="built_in">CFoo</span>()</span><br><span class="line"><span class="keyword">catch</span> error</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>宏</title>
    <url>/2022/11/25/%E5%AE%8F/</url>
    <content><![CDATA[<h2 id="cl-exe-x2F-P-参数"><a href="#cl-exe-x2F-P-参数" class="headerlink" title="cl.exe &#x2F;P 参数"></a>cl.exe &#x2F;P 参数</h2><p><code>/P</code>：生成 <code>.i</code> 文件，用于查看预处理的结果。写复杂宏的时候，可以使用该参数查看宏展开的结果。</p>
<h2 id="数值宏"><a href="#数值宏" class="headerlink" title="数值宏"></a>数值宏</h2><p>宏的内容是数值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159f</span></span><br></pre></td></tr></table></figure>

<p>直接在代码中使用数值的话，可读性不好。可以使用宏来提高代码可读性。</p>
<h2 id="表达式宏"><a href="#表达式宏" class="headerlink" title="表达式宏"></a>表达式宏</h2><p>宏的内容是一个表达式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> AREA(r) ((r)*(r)*PI)</span></span><br></pre></td></tr></table></figure>

<p><strong>注意事项：</strong></p>
<ol>
<li><p>宏的参数要用括号括起来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> AREA(r) (r*r*PI) <span class="comment">// 没有将参数括起来</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> f = AREA(<span class="number">8.5f</span> + <span class="number">0.5f</span>);</span><br><span class="line">    <span class="comment">// 上面这句话的本意应该是：</span></span><br><span class="line">    <span class="comment">// float f = (9.0f*9.0f*PI);</span></span><br><span class="line">    <span class="comment">// 但是因为宏的参数没加括号，宏展开后就成了下面这样</span></span><br><span class="line">    <span class="comment">// float f = (8.5f + 0.5f*8.5f + 0.5f*PI);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>整个宏表达式要用括号括起来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADD(x, y) x+y <span class="comment">// 没有将参数括起来</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = ADD(<span class="number">5</span>, <span class="number">10</span>) * <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 上面这句话的本意应该是:</span></span><br><span class="line">    <span class="comment">// int n = (5+10) * 2;  n的值为30</span></span><br><span class="line">    <span class="comment">// 但是因为整个宏表达式没有用括号括起来，宏展开后就成了下面这样</span></span><br><span class="line">    <span class="comment">// int n = 5+10 * 2;  n的值为25</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="代码段宏"><a href="#代码段宏" class="headerlink" title="代码段宏"></a>代码段宏</h2><p>宏的内容是多条代码语句。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印内容并换行</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHOW_INFO(s)    printf(s);printf(<span class="string">&quot;\r\n&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    SHOW_INFO(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在使用代码段宏时要注意，代码段宏虽然在使用的时候只有一行，但是其展开后是多行语句。所以在 <code>for</code>、<code>if</code> 等语句中使用代码段宏要多加小心。比如下面这个代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印内容并换行</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHOW_INFO(s)    printf(s);printf(<span class="string">&quot;\r\n&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        SHOW_INFO(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本来是想使用 <code>SHOW_INFO</code> 宏来打印三行的 “Hello”，输出内容应该是下面这样:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure>

<p>但是执行以后发现，输出内容都在同一行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HelloHelloHello</span><br></pre></td></tr></table></figure>

<p>这是因为 <code>SHOW_INFO</code> 是由两条语句构成的，宏展开后就是下面这个样子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>可以看到，for 循环的循环体就只有第一句 <code>printf(&quot;Hello&quot;);</code>。所以输出了三次 “Hello”，最后才输出了一次回车换行。</p>
<p>为了避免这种情况的产生，在编码时一定要注意编码规范， <code>for</code>、<code>if</code> 等语句即使只有一句，也要加上花括号。</p>
<h2 id="兼容性宏"><a href="#兼容性宏" class="headerlink" title="兼容性宏"></a>兼容性宏</h2><p>下面这段代码在 VC6.0 中会报错，而 vs20xx 不会报错。</p>
<p>VC6.0 认为第一个 for 循环定义的这个变量 i 是局部变量，所以第二个 for 重复定义了。</p>
<p>VS20xx 认为 for 循环定义的变量 i 是一个块变量，所以不会报错。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;123\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;123\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似于上面这种情况，当代码在不同环境下编译或运行时，需要修改代码。为了代码可以兼容不同的情况，就可以使用兼容性宏。</p>
<p>比如，可以定义下面这个宏：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> for <span class="keyword">if</span>(1)for</span></span><br></pre></td></tr></table></figure>

<p>宏展开后，就变成了下面这样。将 for 循环放入了 if 的代码块中，这样 i 就变成了块变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span>)<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;123\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span>)<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;123\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种写法如下。这种写法的原理和上面是一样的，都是将 for 循环放入了一个代码块中，只不过这是放在 else 的代码块。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> for <span class="keyword">if</span>(0)&#123;&#125;<span class="keyword">else</span></span></span><br></pre></td></tr></table></figure>

<h2 id="编译选项宏"><a href="#编译选项宏" class="headerlink" title="编译选项宏"></a>编译选项宏</h2><p>在编译时可以使用 <code>/D</code> 参数来定义宏，如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cl /D&quot;IS_DEBUG&quot;</span><br></pre></td></tr></table></figure>

<h2 id="编译器内置宏（非标准）"><a href="#编译器内置宏（非标准）" class="headerlink" title="编译器内置宏（非标准）"></a>编译器内置宏（非标准）</h2><p><code>__FILE__</code> ：字符串常量，当前源码文件的绝对路径。</p>
<p><code>__LINE__</code>：字符串常量，当前语句在源码中的行号。</p>
<p><code>_MSC_VER</code>：编译器版本。（微软编译器的宏）</p>
<h2 id="说明性宏"><a href="#说明性宏" class="headerlink" title="说明性宏"></a>说明性宏</h2><p>仅起到说明意义的宏</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OUT</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFunc</span><span class="params">(IN <span class="type">int</span> n, OUT <span class="type">int</span>* pnSize)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="井号和双井号"><a href="#井号和双井号" class="headerlink" title="井号和双井号"></a>井号和双井号</h2><p>一个 # 表示将参数转为字符串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STRING(s)   #s</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> szStr[] = STRING(Hello);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面这个程序宏展开后就是下面这样。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> szStr[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个 # 表示宏连接，它的作用是将两边的符号链接成一个符号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_INT(s)  int n##s</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    DEF_INT(Test) = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面这个程序宏展开后就是下面这样。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nTest = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="宏连接常用的场景"><a href="#宏连接常用的场景" class="headerlink" title="宏连接常用的场景"></a>宏连接常用的场景</h2><p>两个函数功能一样，但是参数类型不同时。C++模板的底层就是做的下面这些事情。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_MAX(type) type my_max_##type(type x, type y) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">    return x &gt; y ? x : y; \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_MAX(type) my_max_##type</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于C++的模板实例化</span></span><br><span class="line">DEF_MAX(<span class="type">int</span>);</span><br><span class="line">DEF_MAX(<span class="type">float</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 类似于C++的模板调用</span></span><br><span class="line">    CALL_MAX(<span class="type">int</span>)(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">    CALL_MAX(<span class="type">float</span>)(<span class="number">1.6f</span>, <span class="number">8.9f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码宏展开后如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_max_int</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; <span class="keyword">return</span> x &gt; y ? x : y; &#125;;</span><br><span class="line"><span class="type">float</span> <span class="title function_">my_max_float</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y)</span> &#123; <span class="keyword">return</span> x &gt; y ? x : y; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    my_max_int(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">    my_max_float(<span class="number">1.6f</span>, <span class="number">8.9f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="T-和-T"><a href="#T-和-T" class="headerlink" title="_T 和 __T"></a>_T 和 __T</h2><p>当程序使用 Unicode 编码时，<code>_T</code> 和 <code>__T</code> 的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __T(x) L ## x</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _T(x) __T(x)</span></span><br></pre></td></tr></table></figure>

<p>为什么不能直接使用 <code>#define _T(x) L ## x</code>，还要多定义一个 <code>__T</code> ？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _T(x) L ## x</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYHELLO <span class="string">&quot;Hello&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    _T(MYHELLO);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个程序，<code>_T</code> 宏展开后的结果如下，<code>L</code> 直接和宏名 <code>MYHELLO</code> 拼接在一起了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    LMYHELLO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果再定义一个宏 <code>__T</code>。 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __T(x)  L ## x</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _T(x)   __T(x)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYHELLO <span class="string">&quot;Hello&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    _T(MYHELLO);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>宏展开结果如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">L&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常用的预定义宏"><a href="#常用的预定义宏" class="headerlink" title="常用的预定义宏"></a>常用的预定义宏</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//	__FILE__			宏所在文件的源文件名 </span></span><br><span class="line"><span class="comment">//	__LINE__			宏所在行的行号</span></span><br><span class="line"><span class="comment">//	__DATE__			代码编译的日期</span></span><br><span class="line"><span class="comment">//	__TIME__			代码编译的时间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, __FILE__);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, __LINE__);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, __DATE__);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, __TIME__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>实现简易的智能指针</title>
    <url>/2022/11/24/%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h2 id="自己实现一个简易的智能指针"><a href="#自己实现一个简易的智能指针" class="headerlink" title="自己实现一个简易的智能指针"></a>自己实现一个简易的智能指针</h2><h3 id="设计一个智能指针类"><a href="#设计一个智能指针类" class="headerlink" title="设计一个智能指针类"></a>设计一个智能指针类</h3><p>实现一个<code>CSmartPtr</code>类，让它可以像一个指针来使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CFoo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CFoo</span>() &#123; cout &lt;&lt; <span class="string">&quot;CFoo::CFoo&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">CFoo</span>() &#123; cout &lt;&lt; <span class="string">&quot;Cfoo::~CFoo&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;CFoo::Test&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自己实现的智能指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSmartPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CSmartPtr</span>(CFoo* p) :<span class="built_in">m_p</span>(p) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">CSmartPtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_p != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_p;</span><br><span class="line">            m_p = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//CFoo* Get()const &#123; return m_p; &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重载-&gt;运算符，使其可以像指针一样直接使用。</span></span><br><span class="line">    CFoo* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重载*运算符，使其支持类似于指针的解引用操作</span></span><br><span class="line">    CFoo&amp; <span class="keyword">operator</span>*()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *m_p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重载[]运算符，使其支持下标运算</span></span><br><span class="line">    CFoo&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> nIdx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_p[nIdx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> CSmartPtr&amp; ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_p == ptr.m_p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> CSmartPtr&amp; ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> !(*<span class="keyword">this</span> == ptr);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CFoo* m_p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//CFoo* p = new CFoo();</span></span><br><span class="line">    <span class="comment">//(*p)</span></span><br><span class="line">    <span class="function">CSmartPtr <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> CFoo)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ptr.Get()-&gt;Test(); //功能没问题，用着没有指针舒服</span></span><br><span class="line"></span><br><span class="line">    ptr-&gt;<span class="built_in">Test</span>();</span><br><span class="line">    (*ptr).<span class="built_in">Test</span>();</span><br><span class="line"></span><br><span class="line">    CFoo* p = <span class="keyword">new</span> CFoo;</span><br><span class="line">    CFoo* p1 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (p == p1)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p>两个智能指针之间进行赋值时存在的问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CFoo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CFoo</span>() &#123; cout &lt;&lt; <span class="string">&quot;CFoo::CFoo&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">CFoo</span>() &#123; cout &lt;&lt; <span class="string">&quot;Cfoo::~CFoo&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;CFoo::Test&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSmartPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CSmartPtr</span>(CFoo* p) :<span class="built_in">m_p</span>(p) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">CSmartPtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_p != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_p;</span><br><span class="line">            m_p = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    CFoo* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_p;</span><br><span class="line">    &#125;</span><br><span class="line">    CFoo&amp; <span class="keyword">operator</span>*()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *m_p;</span><br><span class="line">    &#125;</span><br><span class="line">    CFoo&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> nIdx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_p[nIdx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> CSmartPtr&amp; ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_p == ptr.m_p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> CSmartPtr&amp; ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> !(*<span class="keyword">this</span> == ptr);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CFoo* m_p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CSmartPtr <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> CFoo)</span></span>;</span><br><span class="line">    <span class="function">CSmartPtr <span class="title">ptr2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    ptr1 = ptr2;  <span class="comment">//内存泄漏</span></span><br><span class="line">    <span class="comment">// 默认的赋值运算符重载执行的是浅拷贝</span></span><br><span class="line">    <span class="comment">// 执行完后，ptr1.m_p = ptr2.m_p，两者都等于nullptr。</span></span><br><span class="line">    <span class="comment">// ptr1最开始时申请的那个内存指针丢失了，造成了内存泄漏。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">CSmartPtr <span class="title">ptr3</span><span class="params">(<span class="keyword">new</span> CFoo)</span></span>;</span><br><span class="line">    <span class="function">CSmartPtr <span class="title">ptr4</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    ptr4 = ptr3;  <span class="comment">//重复释放</span></span><br><span class="line">    <span class="comment">// 默认的赋值运算符重载执行的是浅拷贝</span></span><br><span class="line">    <span class="comment">// 执行完后，ptr4 = ptr3，两者指向的同一个堆块地址。</span></span><br><span class="line">    <span class="comment">// 所以当ptr3和ptr4析构时，就会delete同一个地址，造成重复释放</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用引用计数来解决这个问题"><a href="#使用引用计数来解决这个问题" class="headerlink" title="使用引用计数来解决这个问题"></a>使用引用计数来解决这个问题</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CFoo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CFoo</span>() &#123; cout &lt;&lt; <span class="string">&quot;CFoo::CFoo&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">CFoo</span>() &#123; cout &lt;&lt; <span class="string">&quot;Cfoo::~CFoo&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;CFoo::Test&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">    <span class="type">int</span> m_n = <span class="number">0xaaaaaaaa</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSmartPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CSmartPtr</span>(CFoo* p)</span><br><span class="line">    &#123;</span><br><span class="line">        m_p = p;</span><br><span class="line">        m_pnRefCount = <span class="keyword">new</span> <span class="built_in">size_t</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 默认构造</span></span><br><span class="line">    <span class="built_in">CSmartPtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_p = <span class="literal">nullptr</span>;</span><br><span class="line">        m_pnRefCount = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拷贝构造</span></span><br><span class="line">    <span class="built_in">CSmartPtr</span>(<span class="type">const</span> CSmartPtr&amp; ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//然后赋值拷贝</span></span><br><span class="line">        m_p = ptr.m_p;</span><br><span class="line">        m_pnRefCount = ptr.m_pnRefCount;</span><br><span class="line">        <span class="keyword">if</span> (m_pnRefCount != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++(*m_pnRefCount); <span class="comment">//增加计数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">CSmartPtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DecRefcount</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重载赋值运算符</span></span><br><span class="line">    CSmartPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CSmartPtr&amp; ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//检查引用计数</span></span><br><span class="line">        <span class="built_in">DecRefcount</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//然后赋值拷贝</span></span><br><span class="line">        m_p = ptr.m_p;</span><br><span class="line">        m_pnRefCount = ptr.m_pnRefCount;</span><br><span class="line">        <span class="keyword">if</span> (m_pnRefCount != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++(*m_pnRefCount); <span class="comment">//增加计数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    CFoo* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_p;</span><br><span class="line">    &#125;</span><br><span class="line">    CFoo&amp; <span class="keyword">operator</span>*()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *m_p;</span><br><span class="line">    &#125;</span><br><span class="line">    CFoo&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> nIdx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_p[nIdx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> CSmartPtr&amp; ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_p == ptr.m_p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> CSmartPtr&amp; ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> !(*<span class="keyword">this</span> == ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 减少引用计数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DecRefcount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_pnRefCount != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (--(*m_pnRefCount) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">delete</span> m_p;</span><br><span class="line">                <span class="keyword">delete</span> m_pnRefCount;</span><br><span class="line">                m_p = <span class="literal">nullptr</span>;</span><br><span class="line">                m_pnRefCount = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CFoo* m_p; <span class="comment">//保存的对象</span></span><br><span class="line">    <span class="type">size_t</span>* m_pnRefCount; <span class="comment">//引用计数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CSmartPtr <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> CFoo)</span></span>;</span><br><span class="line">    <span class="function">CSmartPtr <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> CFoo)</span></span>;</span><br><span class="line"></span><br><span class="line">    ptr = ptr2;</span><br><span class="line"></span><br><span class="line">    CSmartPtr ptr3;</span><br><span class="line">    ptr = ptr3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="使用自己实现的智能指针"><a href="#使用自己实现的智能指针" class="headerlink" title="使用自己实现的智能指针"></a>使用自己实现的智能指针</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CFoo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CFoo</span>() &#123; cout &lt;&lt; <span class="string">&quot;CFoo::CFoo&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">CFoo</span>() &#123; cout &lt;&lt; <span class="string">&quot;Cfoo::~CFoo&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;CFoo::Test&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">    <span class="type">int</span> m_n = <span class="number">0xaaaaaaaa</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSmartPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CSmartPtr</span>(CFoo* p)</span><br><span class="line">    &#123;</span><br><span class="line">        m_p = p;</span><br><span class="line">        m_pnRefCount = <span class="keyword">new</span> <span class="built_in">size_t</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">CSmartPtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DecRefcount</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CSmartPtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_p = <span class="literal">nullptr</span>;</span><br><span class="line">        m_pnRefCount = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CSmartPtr</span>(<span class="type">const</span> CSmartPtr&amp; ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//然后赋值拷贝</span></span><br><span class="line">        m_p = ptr.m_p;</span><br><span class="line">        m_pnRefCount = ptr.m_pnRefCount;</span><br><span class="line">        <span class="keyword">if</span> (m_pnRefCount != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++(*m_pnRefCount); <span class="comment">//增加计数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    CSmartPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CSmartPtr&amp; ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//检查引用计数</span></span><br><span class="line">        <span class="built_in">DecRefcount</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//然后赋值拷贝</span></span><br><span class="line">        m_p = ptr.m_p;</span><br><span class="line">        m_pnRefCount = ptr.m_pnRefCount;</span><br><span class="line">        <span class="keyword">if</span> (m_pnRefCount != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++(*m_pnRefCount); <span class="comment">//增加计数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    CFoo* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_p;</span><br><span class="line">    &#125;</span><br><span class="line">    CFoo&amp; <span class="keyword">operator</span>*()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *m_p;</span><br><span class="line">    &#125;</span><br><span class="line">    CFoo&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> nIdx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_p[nIdx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> CSmartPtr&amp; ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_p == ptr.m_p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> CSmartPtr&amp; ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> !(*<span class="keyword">this</span> == ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DecRefcount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_pnRefCount != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (--(*m_pnRefCount) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">delete</span> m_p;</span><br><span class="line">                <span class="keyword">delete</span> m_pnRefCount;</span><br><span class="line">                m_p = <span class="literal">nullptr</span>;</span><br><span class="line">                m_pnRefCount = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CFoo* m_p; <span class="comment">//保存的对象</span></span><br><span class="line">    <span class="type">size_t</span>* m_pnRefCount; <span class="comment">//引用计数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">CSmartPtr <span class="title">Test1</span><span class="params">(CSmartPtr ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CSmartPtr ptr0 = ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CSmartPtr</span>(ptr0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CSmartPtr g_ptr;</span><br><span class="line"><span class="function">CSmartPtr <span class="title">Test2</span><span class="params">(CSmartPtr ptr3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_ptr = <span class="built_in">Test1</span>(ptr3);</span><br><span class="line">    <span class="keyword">return</span> g_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CSmartPtr <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> CFoo)</span></span>;</span><br><span class="line">    <span class="built_in">Test2</span>(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="标准库中的智能指针"><a href="#标准库中的智能指针" class="headerlink" title="标准库中的智能指针"></a>标准库中的智能指针</h2><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>带引用计数的智能指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CFoo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CFoo</span>() &#123; cout &lt;&lt; <span class="string">&quot;CFoo::CFoo&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">CFoo</span>() &#123; cout &lt;&lt; <span class="string">&quot;Cfoo::~CFoo&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;CFoo::Test&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">    <span class="type">int</span> m_n = <span class="number">0xaaaaaaaa</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">shared_ptr&lt;CFoo&gt; <span class="title">Test1</span><span class="params">(shared_ptr&lt;CFoo&gt; ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shared_ptr&lt;CFoo&gt; ptr0 = ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;CFoo&gt;(ptr0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shared_ptr&lt;CFoo&gt; g_ptr;</span><br><span class="line"><span class="function">shared_ptr&lt;CFoo&gt; <span class="title">Test2</span><span class="params">(shared_ptr&lt;CFoo&gt; ptr3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_ptr = <span class="built_in">Test1</span>(ptr3);</span><br><span class="line">    <span class="keyword">return</span> g_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;CFoo&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> CFoo)</span></span>;</span><br><span class="line">    ptr-&gt;m_n = <span class="number">0xBBBBBBBB</span>;</span><br><span class="line">    (*ptr).<span class="built_in">Test</span>();</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test2</span>(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>引用</title>
    <url>/2022/11/24/%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><strong>引用（reference）</strong>就是为对象起一个别名。引用的本质其实和指针类似，都是存的地址（目前的编译器是这么实现的）。</p>
<ul>
<li><p>引用的类型必须与其所引用对象的类型一致。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="number">0.0f</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref1 = n;	<span class="comment">// 正确</span></span><br><span class="line"><span class="type">int</span>&amp; ref2 = f;	<span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>引用类型在初始化时就确定所要引用的对象，之后就无法再对其他对象进行引用。所以<strong>引用类型必须初始化</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n1 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n2 = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref1 = n1;	<span class="comment">// 正确</span></span><br><span class="line"><span class="type">int</span>&amp; ref2;		<span class="comment">// 错误，引用未进行初始化</span></span><br><span class="line"></span><br><span class="line">ref1 = n2		<span class="comment">// 这是一条赋值语句，相当于 n1 = n2; 并不会让ref1变成n2的引用</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>有多级指针，但是没有多级引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref1 = n;</span><br><span class="line"><span class="type">int</span>&amp;&amp; ref2 = ref1;	<span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>引用不能引用常量，但是 <code>const</code> 修饰的引用可以引用常量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>&amp; ref1 = <span class="number">9</span>;		  <span class="comment">// 错误</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; ref2 = <span class="number">9</span>;  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不要返回局部变量的引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当函数返回时，该函数的栈空间就失效了，使用其中变量的引用就是一个非法操作</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h2><p>引用的类型必须与其所引用对象的类型一致，但是有两个例外情况。第一种例外情况就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = i;  <span class="comment">// 允许常量引用绑定到非常量对象</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = r1 * <span class="number">2</span>;  <span class="comment">// 正确</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r3 = r1 * <span class="number">2</span>;  <span class="comment">// 错误：r3普通引用，不能用表达式进行初始化。</span></span><br></pre></td></tr></table></figure>

<p>要理解这种例外情况的原因，就需要弄清楚当一个常量引用绑定到另外一种类型上时到底发生了什么：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ri = dval;</span><br></pre></td></tr></table></figure>

<p>编译器将上面的代码变成如下形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> temp = dval;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ri = temp;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，<code>ri</code>绑定的是一个<strong>临时对象</strong>。临时对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名对象。</p>
<p>如果<code>ri</code>不是常量引用，而是普通引用。那么就允许通过<code>ri</code>进行修改，这样就会改变<code>ri</code>所引用对象的值。而<code>ri</code>引用的是一个临时对象，这样就变成了对临时变量的修改。显然这是一种不合理的行为。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>拷贝与引用计数</title>
    <url>/2022/11/24/%E6%8B%B7%E8%B4%9D%E4%B8%8E%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>浅拷贝只复制值，相当于直接<code>memcpy</code>。</p>
<p><strong>浅拷贝存在的问题</strong>：</p>
<ul>
<li>重复释放</li>
<li>一个对象进行了修改，会影响所有对象。</li>
<li>一个对象释放，则其他对象都无法再使用。</li>
</ul>
<hr>
<p>下面代码中的拷贝构造函数就是浅拷贝，只是单纯将值拷贝过去。<code>base1</code>和<code>base2</code> 的成员指向了同一块内存。</p>
<ul>
<li><p>如果修改 <code>base1</code> 中的字符串，<code>base2</code> 也会受到影响。</p>
</li>
<li><p>如果 <code>base2</code> 的生命周期结束了，执行析构函数释放了<code>m_pBuf</code>指向的内存。那么 <code>base1</code> 的 <code>m_pBuf</code> 就无法使用了，因为它所指向的内存已经被释放了。而且<code>base1</code>在执行析构函数时，还会造成重复释放问题。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">const</span> <span class="type">char</span>* str)</span><br><span class="line">    &#123;</span><br><span class="line">        m_pBuf = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(m_pBuf, str, <span class="built_in">strlen</span>(str) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Base</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_pBuf != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] m_pBuf;</span><br><span class="line">            m_pBuf = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">const</span> Base&amp; base)  <span class="comment">// 浅拷贝</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// memcpy(this, &amp;base, sizeof(Base));</span></span><br><span class="line">        m_pBuf = base.m_pBuf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* m_pBuf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">base1</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Base <span class="title">base2</span><span class="params">(base1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>下面的拷贝函数就是深拷贝。不是单纯的拷贝指针值，而是另外申请空间，然后将内容拷贝到新空间中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">const</span> <span class="type">char</span>* str)</span><br><span class="line">    &#123;</span><br><span class="line">        m_pBuf = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(m_pBuf, str, <span class="built_in">strlen</span>(str) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Base</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_pBuf != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] m_pBuf;</span><br><span class="line">            m_pBuf = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">const</span> Base&amp; base)  <span class="comment">// 深拷贝</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_pBuf = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(base.m_pBuf) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(m_pBuf, base.m_pBuf, <span class="built_in">strlen</span>(base.m_pBuf) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* m_pBuf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">base1</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Base <span class="title">base2</span><span class="params">(base1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>深拷贝有可能造成内存浪费。</strong></p>
<p>假设拷贝了50个对象，其中只有一个需要对内容进行修改，其他49个对象都没有修改。那么这49个对象存的都是一样的内容，却申请了49个空间，造成了内存浪费。</p>
<h2 id="写时拷贝"><a href="#写时拷贝" class="headerlink" title="写时拷贝"></a>写时拷贝</h2><p>一开始拷贝的时候，执行的是浅拷贝。当某个对象需要修改的时候，则为其申请新的内存，复制内容到新内存中，让其在新内存中做修改。这样就不会影响其他对象了。</p>
<p>使用写时拷贝就需要一个计数器记录下有多少个对象使用同一块内存，这就是<strong>引用计数</strong>。</p>
<p>计数值最好放到堆中，每块内存分配一个独立的计数器。当引用这块内存的对象数量发生改变时，将计数器的值一起改变。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CTest</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CTest</span>() = <span class="keyword">delete</span>;</span><br><span class="line">	<span class="comment">// 构造函数</span></span><br><span class="line">	<span class="built_in">CTest</span>(<span class="type">const</span> <span class="type">char</span>* str)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 申请内存</span></span><br><span class="line">		m_nSize = <span class="built_in">strlen</span>(str) + <span class="number">1</span>;</span><br><span class="line">		m_pBuffer = <span class="keyword">new</span> <span class="type">char</span>[m_nSize];</span><br><span class="line">		<span class="built_in">memcpy</span>(m_pBuffer, str, <span class="built_in">strlen</span>(str) + <span class="number">1</span>);</span><br><span class="line">		<span class="comment">// 初始化引用计数</span></span><br><span class="line">		m_pnCount = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 拷贝构造</span></span><br><span class="line">	<span class="built_in">CTest</span>(<span class="type">const</span> CTest&amp; obj)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 只进行浅拷贝</span></span><br><span class="line">		m_pBuffer = obj.m_pBuffer;</span><br><span class="line">		m_pnCount = obj.m_pnCount;</span><br><span class="line">		m_nSize = obj.m_nSize;</span><br><span class="line">		<span class="comment">// 引用计数加一</span></span><br><span class="line">		(*m_pnCount)++;</span><br><span class="line">		<span class="comment">// 由于引用计数保存在堆中，此处会改变所有使用了同一块Buffer的对象的引用计数</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 减少引用计数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">DecCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// 引用计数减一</span></span><br><span class="line">		(*m_pnCount)--;</span><br><span class="line">		<span class="comment">// 引用计数为0时，释放内存</span></span><br><span class="line">		<span class="keyword">if</span> (m_pBuffer != <span class="literal">nullptr</span> &amp;&amp; *m_pnCount == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span>[] m_pBuffer;</span><br><span class="line">			m_pBuffer = <span class="literal">nullptr</span>;</span><br><span class="line">			<span class="keyword">delete</span> m_pnCount;</span><br><span class="line">			m_pnCount = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		m_nSize = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 析构函数</span></span><br><span class="line">	~<span class="built_in">CTest</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 减少引用计数</span></span><br><span class="line">		<span class="built_in">DecCount</span>();</span><br><span class="line">		m_pBuffer = <span class="literal">nullptr</span>;</span><br><span class="line">		m_pnCount = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Modify</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// 当需要修改时，申请新的内存，将数据拷贝到新内存中。</span></span><br><span class="line">		<span class="type">char</span>* p = <span class="keyword">new</span> <span class="type">char</span>[m_nSize];</span><br><span class="line">		<span class="built_in">memcpy</span>(p, m_pBuffer, m_nSize);</span><br><span class="line">		m_pBuffer = p;</span><br><span class="line">		<span class="comment">// 减少引用计数</span></span><br><span class="line">		<span class="built_in">DecCount</span>();</span><br><span class="line">		<span class="comment">// 创建新的引用计数</span></span><br><span class="line">		m_pnCount = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="comment">// 修改内容</span></span><br><span class="line">		m_pBuffer[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nSize;  <span class="comment">// Buffer的大小</span></span><br><span class="line">	<span class="type">char</span>* m_pBuffer;  <span class="comment">// Buffer</span></span><br><span class="line">	<span class="type">int</span>* m_pnCount;  <span class="comment">// 引用计数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>指针</title>
    <url>/2022/11/25/%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h2 id="指针知识点"><a href="#指针知识点" class="headerlink" title="指针知识点"></a>指针知识点</h2><p>指针没有隐式转换，只能进行强转。</p>
<p>下标访问的效率不低于指针。指针优化后的效率才等于下标访问的效率。</p>
<p>数组名是第 0 个元素的指针常量。</p>
<p>数组名经过传参后就变成指针了。</p>
<h2 id="指针运算法则"><a href="#指针运算法则" class="headerlink" title="指针运算法则"></a>指针运算法则</h2><h3 id="指针加整型"><a href="#指针加整型" class="headerlink" title="指针加整型"></a>指针加整型</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type *ptr = ...;</span><br><span class="line"><span class="type">int</span> n = ...;</span><br><span class="line"></span><br><span class="line">ptr + n = (<span class="type">int</span>)ptr + <span class="keyword">sizeof</span>(type)*n</span><br><span class="line">		指针加整型，结果为同类型指针常量</span><br><span class="line">        = (type*)((<span class="type">int</span>)ptr + <span class="keyword">sizeof</span>(type)*n)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="指针做下标运算"><a href="#指针做下标运算" class="headerlink" title="指针做下标运算"></a>指针做下标运算</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type *ptr = ...;</span><br><span class="line"><span class="type">int</span> n = ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对指针作下标运算，会发生间接访问</span></span><br><span class="line">ptr[n] = *(type*)((<span class="type">int</span>)ptr + <span class="keyword">sizeof</span>(type)*n)</span><br></pre></td></tr></table></figure>

<h3 id="amp-互为逆运算"><a href="#amp-互为逆运算" class="headerlink" title="&amp;*互为逆运算"></a>&amp;*互为逆运算</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type *ptr = ...;</span><br><span class="line"><span class="type">int</span> n = ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &amp;*互为逆运算</span></span><br><span class="line">*&amp;n   == n</span><br><span class="line">&amp;*ptr == ptr</span><br></pre></td></tr></table></figure>

<h3 id="同类型指针相减"><a href="#同类型指针相减" class="headerlink" title="同类型指针相减"></a>同类型指针相减</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type *p1 = ...;</span><br><span class="line">type *p2 = ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同类型指针相减，得到整型常量</span></span><br><span class="line">p1 - p2 = ((<span class="type">int</span>)p1 - (<span class="type">int</span>)p2) / <span class="keyword">sizeof</span>(type)</span><br></pre></td></tr></table></figure>

<h2 id="void-指针"><a href="#void-指针" class="headerlink" title="void 指针"></a>void 指针</h2><p>void指针不能进行运算和取值，因为没有解释信息。</p>
<p>void 指针可以接收其他类型指针，其他类型的指针不能接收 void 指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">666</span>;</span><br><span class="line"><span class="type">int</span> *pn = <span class="literal">NULL</span>;</span><br><span class="line">pn = &amp;n;</span><br><span class="line"><span class="type">void</span> *pv = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">pv = pn; <span class="comment">// 可以</span></span><br><span class="line"><span class="comment">// pn = pv; 不行</span></span><br></pre></td></tr></table></figure>

<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>指针都需要有解释信息，函数指针需要三种解释信息：</p>
<ol>
<li>函数的参数序列：参数个数、参数类型、参数顺序</li>
<li>函数所使用的调用约定</li>
<li>函数有没有返回值，返回值的类型是什么。</li>
</ol>
<p>参数序列、调用约定和返回值类型三者都一样的函数，就是<strong>同类型函数</strong>。<strong>同类型函数</strong>可以起到统一接口的作用，可以进行批量处理。</p>
<p>通过<strong>函数指针</strong>调用函数是<strong>间接调用</strong>。</p>
<p>使用函数指针间接调用的方式有两种，两者产生的汇编代码是一样的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> (__cdecl *pfn)(<span class="type">int</span>, <span class="type">int</span>) = <span class="literal">NULL</span>;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 这两种调用方式是一样的</span></span><br><span class="line">(*pfn)(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">pfn(<span class="number">5</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>文件流（文件操作）</title>
    <url>/2022/11/24/%E6%96%87%E4%BB%B6%E6%B5%81/</url>
    <content><![CDATA[<h1 id="文件流（文件操作）"><a href="#文件流（文件操作）" class="headerlink" title="文件流（文件操作）"></a>文件流（文件操作）</h1><p>C++ 中的文件流操作需要使用到 <code>fstream</code> 标准库。</p>
<p><code>fstream</code> 无法进行连续的读写操作。</p>
<h2 id="文件的打开方式"><a href="#文件的打开方式" class="headerlink" title="文件的打开方式"></a>文件的打开方式</h2><p><img  
                     lazyload
                     alt="image"
                     data-src="/images/%E6%96%87%E4%BB%B6%E6%B5%81.assets/image-20220821230732142.png"
                      alt="image-20220821230732142"
                ></p>
<h2 id="以文本形式写文件"><a href="#以文本形式写文件" class="headerlink" title="以文本形式写文件"></a>以文本形式写文件</h2><p>操作方式和 <code>cout</code> 是基本一样的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 实例化一个文件流对象</span></span><br><span class="line">	fstream fs;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打开文件流</span></span><br><span class="line">	fs.<span class="built_in">open</span>(<span class="string">&quot;hello.txt&quot;</span>, ios_base::in | ios_base::out);</span><br><span class="line">	<span class="comment">// 判断是否打开成功</span></span><br><span class="line">	<span class="keyword">if</span> (!fs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 往文件流中写入内容</span></span><br><span class="line">	fs &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">	fs &lt;&lt; hex &lt;&lt; <span class="number">0x11223344</span> &lt;&lt; endl;</span><br><span class="line">	fs &lt;&lt; <span class="number">3.14159</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">// 关闭文件流</span></span><br><span class="line">	fs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="以文本形式读文件"><a href="#以文本形式读文件" class="headerlink" title="以文本形式读文件"></a>以文本形式读文件</h2><p>操作方式和 <code>cin</code> 是基本一样的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 实例化一个文件流对象</span></span><br><span class="line">	fstream fs;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打开文件流</span></span><br><span class="line">	fs.<span class="built_in">open</span>(<span class="string">&quot;hello.txt&quot;</span>, ios_base::in | ios_base::out);</span><br><span class="line">	<span class="comment">// 判断是否打开成功</span></span><br><span class="line">	<span class="keyword">if</span> (!fs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从文件流中读取内容</span></span><br><span class="line">	<span class="type">char</span> buf[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">int</span> nVal = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	fs.<span class="built_in">getline</span>(buf, <span class="number">100</span>);</span><br><span class="line">	fs &gt;&gt; nVal;  <span class="comment">// 与cin类似，遇到空格、回车等截断字符，就会停止读取</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭文件流</span></span><br><span class="line">	fs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="以二进制形式写文件"><a href="#以二进制形式写文件" class="headerlink" title="以二进制形式写文件"></a>以二进制形式写文件</h2><p>使用<code>write</code>函数进行二进制写入。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 实例化一个文件流对象</span></span><br><span class="line">	fstream fs;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打开文件流</span></span><br><span class="line">	fs.<span class="built_in">open</span>(<span class="string">&quot;hello.txt&quot;</span>, ios_base::in | ios_base::out);</span><br><span class="line">	<span class="comment">// 判断是否打开成功</span></span><br><span class="line">	<span class="keyword">if</span> (!fs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 往文件流中写入数据</span></span><br><span class="line">	<span class="type">char</span> szBuf[] = <span class="string">&quot;hello wrold&quot;</span>;</span><br><span class="line"></span><br><span class="line">	fs.<span class="built_in">write</span>(szBuf, <span class="built_in">sizeof</span>(szBuf)); <span class="comment">// 字符串结束符\0也会被写入</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭文件流</span></span><br><span class="line">	fs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="以二进制形式读文件"><a href="#以二进制形式读文件" class="headerlink" title="以二进制形式读文件"></a>以二进制形式读文件</h2><p>使用<code>read</code>函数进行二进制读取。</p>
<p>fstream 与 C 语言中的文件操作类似，在读写时，并不是直接更新文件，而是有一个缓存，先在缓存中进行更新。</p>
<p>在执行了<code>write</code>以后，内容并没有立马更新到文件中，只是写当了缓存中。如果此时直接使用<code>read</code>进行读取，读取的是缓存中<code>hello world</code>后面的内容。所以需要设置文件指针，将其设置到缓存的首部。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 实例化一个文件流对象</span></span><br><span class="line">	fstream fs;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打开文件流</span></span><br><span class="line">	fs.<span class="built_in">open</span>(<span class="string">&quot;hello.txt&quot;</span>, ios_base::in | ios_base::out | ios_base::trunc);</span><br><span class="line">	<span class="comment">// 判断是否打开成功</span></span><br><span class="line">	<span class="keyword">if</span> (!fs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 往文件流中写入数据</span></span><br><span class="line">	<span class="type">char</span> szBuf[] = <span class="string">&quot;hello wrold&quot;</span>;</span><br><span class="line">	fs.<span class="built_in">write</span>(szBuf, <span class="built_in">sizeof</span>(szBuf)); <span class="comment">// 字符串结束符\0也会被写入</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// fstream无法进行连续的读写操作，需要设置文件指针的位置</span></span><br><span class="line">	fs.<span class="built_in">seekg</span>(<span class="number">0</span>);  <span class="comment">// 设置文件指针到文件头</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 以二进制形式读取数据</span></span><br><span class="line">	<span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line">	fs.<span class="built_in">read</span>(buf, <span class="built_in">sizeof</span>(szBuf));</span><br><span class="line">	cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭文件流</span></span><br><span class="line">	fs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="保存对象数据到文件中（序列化）"><a href="#保存对象数据到文件中（序列化）" class="headerlink" title="保存对象数据到文件中（序列化）"></a>保存对象数据到文件中（序列化）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CStudent</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CStudent</span>(string strName, string strPhone, <span class="type">size_t</span> uAge)</span><br><span class="line">		:<span class="built_in">m_strName</span>(strName), <span class="built_in">m_strPhone</span>(strPhone), <span class="built_in">m_uAge</span>(uAge)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 将当前对象的数据保存到文件中</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SaveFile</span><span class="params">(fstream&amp; fs)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">WriteString</span>(fs, m_strName);</span><br><span class="line">		<span class="built_in">WriteString</span>(fs, m_strPhone);</span><br><span class="line"></span><br><span class="line">		fs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span>*)&amp;m_uAge, <span class="built_in">sizeof</span>(m_uAge));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从文件中读取数据到当前对象</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ReadFile</span><span class="params">(fstream&amp; fs)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">ReadString</span>(fs, m_strName);</span><br><span class="line">		<span class="built_in">ReadString</span>(fs, m_strPhone);</span><br><span class="line"></span><br><span class="line">		fs.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;m_uAge, <span class="built_in">sizeof</span>(m_uAge));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 将一个string类型的字符串保存到文件中</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">WriteString</span><span class="params">(fstream&amp; fs, string&amp; str)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">size_t</span> uSize = str.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">		<span class="comment">// 保存字符串的长度</span></span><br><span class="line">		fs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span>*)&amp;uSize, <span class="built_in">sizeof</span>(uSize));</span><br><span class="line">		<span class="comment">// 保存字符串的数据</span></span><br><span class="line">		fs.<span class="built_in">write</span>(str.<span class="built_in">c_str</span>(), uSize);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从文件中读取一个字符串</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ReadString</span><span class="params">(fstream&amp; fs, string&amp; str)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">size_t</span> uSize = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 读取字符串大小</span></span><br><span class="line">		fs.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;uSize, <span class="built_in">sizeof</span>(uSize));</span><br><span class="line">		<span class="comment">// 申请对应大小的缓存</span></span><br><span class="line">		<span class="type">char</span>* pBuf = <span class="keyword">new</span> <span class="type">char</span>[uSize];</span><br><span class="line">		<span class="keyword">if</span> (pBuf != <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 读取字符串数据到缓存中</span></span><br><span class="line">			fs.<span class="built_in">read</span>(pBuf, uSize);</span><br><span class="line">			str = pBuf;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">delete</span>[] pBuf;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_strName;</span><br><span class="line">	string m_strPhone;</span><br><span class="line">	<span class="type">size_t</span> m_uAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">CStudent <span class="title">stu</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;10086&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	fstream fs;</span><br><span class="line">	fs.<span class="built_in">open</span>(<span class="string">&quot;student.dat&quot;</span>, ios::in | ios::out | ios::trunc);</span><br><span class="line">	<span class="keyword">if</span> (!fs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	stu.<span class="built_in">SaveFile</span>(fs);</span><br><span class="line">	fs.<span class="built_in">seekg</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="function">CStudent <span class="title">stu1</span><span class="params">(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">	stu1.<span class="built_in">ReadFile</span>(fs);</span><br><span class="line"></span><br><span class="line">	fs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>模板</title>
    <url>/2022/11/24/%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><blockquote>
<p><strong>NOTE</strong>：模板的声明和实现要放在同一个文件中，一般都是放在头文件中。不能将声明放在头文件，实现放在.cpp文件。</p>
<p>因为编译时是以.cpp文件为单位的。每个.cpp文件单独编译，然后再链接在一起。</p>
</blockquote>
<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><h3 id="隐式实例化"><a href="#隐式实例化" class="headerlink" title="隐式实例化"></a>隐式实例化</h3><p>不指明类型，编译器根据传入的参数，自动推导出类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Add</span><span class="params">(T val1, T val2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> val1 + val2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 在实例化时没有指明类型</span></span><br><span class="line">	<span class="built_in">Add</span>(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// 隐式实例化</span></span><br><span class="line">	<span class="built_in">Add</span>(<span class="number">1.2</span>, <span class="number">9.8</span>); <span class="comment">// 隐式实例化</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>存在的问题</strong>：如果传入的参数类型不一样的话，编译器就无法确定要使用哪种类型，产生二义性问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Add</span><span class="params">(T val1, T val2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> val1 + val2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Add</span>(<span class="number">10</span>, <span class="number">3.14</span>);  <span class="comment">// 报错，二义性</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以在使用模板时，一般不使用隐式实例化。</p>
<h3 id="显式实例化"><a href="#显式实例化" class="headerlink" title="显式实例化"></a>显式实例化</h3><p>在实例化时使用<code>&lt;&gt;</code>来指明模板的参数类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Add</span><span class="params">(T val1, T val2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> val1 + val2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Add</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>, <span class="number">10</span>);  <span class="comment">// 显式实例化</span></span><br><span class="line">	<span class="built_in">Add</span>&lt;<span class="type">double</span>&gt;(<span class="number">3.14</span>, <span class="number">2.16</span>);  <span class="comment">// 显式实例化</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">Add</span>&lt;<span class="type">double</span>&gt;(<span class="number">10</span>, <span class="number">3.14</span>); <span class="comment">// 显式实例化，不存在二义性问题</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生成函数代码"><a href="#生成函数代码" class="headerlink" title="生成函数代码"></a>生成函数代码</h3><p>模板是在使用的时候才会实例化，实例化了哪种类型，编译器就会生成这种类型的函数代码，不使用不生成。<br>也就是说，如果你写了模板函数，但是代码中并没有使用这个模板函数，那么编译器在生成文件时，是不会在二进制文件中生成该模板函数的代码的。<br>如果你实例化了，比如<code>Add&lt;int&gt;(1,2)</code>，那么编译器在生成代码时只会生成参数类型是<code>int</code>的代码。</p>
<h3 id="模板重载"><a href="#模板重载" class="headerlink" title="模板重载"></a>模板重载</h3><p>例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Add</span><span class="params">(T val1, T val2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> val1 + val2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板重载</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function">T1 <span class="title">Add</span><span class="params">(T1 val1, T2 val2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> val1 + val2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Add</span>&lt;<span class="type">int</span>&gt;(<span class="number">50</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Add</span>&lt;<span class="type">int</span>, <span class="type">double</span>&gt;(<span class="number">5</span>, <span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="模板特例"><a href="#模板特例" class="headerlink" title="模板特例"></a>模板特例</h3><p>为指定类型专门写一个实现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Add</span><span class="params">(T val1, T val2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> val1 + val2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板特例</span></span><br><span class="line"><span class="comment">// 专门为const char*类型写一个实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Add</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s1, <span class="type">const</span> <span class="type">char</span>* s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span>* szRet = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s1) + <span class="built_in">strlen</span>(s2) + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">memcpy</span>(szRet, s1, <span class="built_in">strlen</span>(s1) + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">strcat</span>(szRet, s2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> szRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Add</span>&lt;<span class="type">int</span>&gt;(<span class="number">50</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* p1 = <span class="built_in">Add</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot; world&quot;</span>);  <span class="comment">// 隐式实例化</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* p2 = <span class="built_in">Add</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot; world&quot;</span>);  <span class="comment">// 显式实例化</span></span><br><span class="line">	cout &lt;&lt; p1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span>[] p;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="成员函数模板"><a href="#成员函数模板" class="headerlink" title="成员函数模板"></a>成员函数模板</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CFoo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 在类内实现</span></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">	<span class="type">void</span> <span class="title">Print1</span><span class="params">(T val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在类外实现</span></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">	<span class="type">void</span> <span class="title">Print2</span><span class="params">(T val)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CFoo::Print2</span><span class="params">(T val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CFoo foo1;</span><br><span class="line"></span><br><span class="line">	foo1.<span class="built_in">Print1</span>(<span class="number">10</span>);</span><br><span class="line">	foo1.<span class="built_in">Print2</span>(<span class="number">15.8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="模板特例-1"><a href="#模板特例-1" class="headerlink" title="模板特例"></a>模板特例</h3><ul>
<li><p>在类内实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CFoo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 通用实现</span></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">	T <span class="title">Add</span><span class="params">(T val1, T val2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val1 + val2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 模板特例</span></span><br><span class="line">	<span class="keyword">template</span>&lt;&gt;</span><br><span class="line">	<span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Add</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s1, <span class="type">const</span> <span class="type">char</span>* s2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">char</span>* szRet = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s1) + <span class="built_in">strlen</span>(s2) + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">memcpy</span>(szRet, s1, <span class="built_in">strlen</span>(s1) + <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">strcat</span>(szRet, s2);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> szRet;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CFoo foo1;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; foo1.<span class="built_in">Add</span>(<span class="number">10</span>, <span class="number">80</span>) &lt;&lt; endl;  <span class="comment">// 隐式实例化</span></span><br><span class="line">	cout &lt;&lt; foo1.<span class="built_in">Add</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>, <span class="number">80</span>) &lt;&lt; endl;  <span class="comment">// 显式实例化</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; foo1.<span class="built_in">Add</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot; world&quot;</span>) &lt;&lt; endl;   <span class="comment">// 隐式实例化</span></span><br><span class="line">	cout &lt;&lt; foo1.<span class="built_in">Add</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot; world&quot;</span>) &lt;&lt; endl;  <span class="comment">// 显式实例化</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在类外实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CFoo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 通用实现</span></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">	T <span class="title">Add</span><span class="params">(T val1, T val2)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 模板特例</span></span><br><span class="line">	<span class="keyword">template</span>&lt;&gt;</span><br><span class="line">	<span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Add</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s1, <span class="type">const</span> <span class="type">char</span>* s2)</span></span>;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用实现</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">CFoo::Add</span><span class="params">(T val1, T val2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> val1 + val2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板特例</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">CFoo::Add</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s1, <span class="type">const</span> <span class="type">char</span>* s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span>* szRet = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s1) + <span class="built_in">strlen</span>(s2) + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">memcpy</span>(szRet, s1, <span class="built_in">strlen</span>(s1) + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">strcat</span>(szRet, s2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> szRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CFoo foo1;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; foo1.<span class="built_in">Add</span>(<span class="number">10</span>, <span class="number">80</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; foo1.<span class="built_in">Add</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot; world&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CFoo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 在类内实现成员函数</span></span><br><span class="line">	<span class="built_in">CFoo</span>(T val)</span><br><span class="line">	&#123;</span><br><span class="line">		m_val = val;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在类外实现成员函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(T val)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T m_val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类外实现成员函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> CFoo&lt;T&gt;::<span class="built_in">Print</span>(T val)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 类模板只能显式实例化</span></span><br><span class="line">	<span class="function">CFoo&lt;<span class="type">int</span>&gt; <span class="title">foo1</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	foo1.<span class="built_in">Print</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>NOTE:</strong> 类模板不能隐式实例化，只能显式实例化。</p>
</blockquote>
<h3 id="模板特例-2"><a href="#模板特例-2" class="headerlink" title="模板特例"></a>模板特例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通用实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CFoo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 在类内实现成员函数</span></span><br><span class="line">	<span class="built_in">CFoo</span>(T val)</span><br><span class="line">	&#123;</span><br><span class="line">		m_val = val;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在类外实现成员函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(T val)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T m_val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类外实现成员函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> CFoo&lt;T&gt;::<span class="built_in">Print</span>(T val)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板特例</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CFoo</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 在类内实现成员函数</span></span><br><span class="line">	<span class="built_in">CFoo</span>(<span class="type">const</span> <span class="type">char</span>* val)</span><br><span class="line">	&#123;</span><br><span class="line">		m_val = val;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在类外实现成员函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* val)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* m_val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类外实现成员函数</span></span><br><span class="line"><span class="type">void</span> CFoo&lt;<span class="type">const</span> <span class="type">char</span>*&gt;::<span class="built_in">Print</span>(<span class="type">const</span> <span class="type">char</span>* val)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="继承类模板"><a href="#继承类模板" class="headerlink" title="继承类模板"></a>继承类模板</h3><ul>
<li><p>一般使用方式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CFoo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 在类内实现成员函数</span></span><br><span class="line">	<span class="built_in">CFoo</span>(T val)</span><br><span class="line">	&#123;</span><br><span class="line">		m_val = val;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T m_val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CChild</span> :<span class="keyword">public</span> CFoo&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CChild</span>(T val) :</span><br><span class="line">		<span class="built_in">CFoo</span>&lt;T&gt;(val)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>继承特定类型的类模板</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CFoo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 在类内实现成员函数</span></span><br><span class="line">	<span class="built_in">CFoo</span>(T val)</span><br><span class="line">	&#123;</span><br><span class="line">		m_val = val;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T m_val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CChild</span> :<span class="keyword">public</span> CFoo&lt;<span class="type">int</span>&gt;  <span class="comment">// 只继承CFoo int类型的实例</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CChild</span>(T val) :</span><br><span class="line">		<span class="built_in">CFoo</span>&lt;<span class="type">int</span>&gt;(val)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="使用类模板的嵌套类"><a href="#使用类模板的嵌套类" class="headerlink" title="使用类模板的嵌套类"></a>使用类模板的嵌套类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CFoo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">CTest</span>  <span class="comment">// 嵌套的内部类</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">TestInner</span><span class="params">(T val)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;CTest::TestInner: &quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在类内写实现时，如果用到内部类，和平常的使用方式一样</span></span><br><span class="line">	<span class="function">CTest <span class="title">GetInner1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">CTest</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">CTest <span class="title">GetInner12</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">TestOut</span><span class="params">(T val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;CFoo::TestOut: &quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类外写实现时，如果用到内部类，函数返回值前面要加上typename关键字</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> CFoo&lt;T&gt;::CTest CFoo&lt;T&gt;::<span class="built_in">GetInner12</span>()  <span class="comment">// 开头加了typename关键字</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">CTest</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 对外部类进行实例化</span></span><br><span class="line">	CFoo&lt;<span class="type">int</span>&gt; foo;</span><br><span class="line">	foo.<span class="built_in">TestOut</span>(<span class="number">88</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对内部类进行实例化</span></span><br><span class="line">	CFoo&lt;<span class="type">int</span>&gt;::CTest test;</span><br><span class="line">	test.<span class="built_in">TestInner</span>(<span class="number">55</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="用宏实现模板的功能"><a href="#用宏实现模板的功能" class="headerlink" title="用宏实现模板的功能"></a>用宏实现模板的功能</h2><p>指针类型和 const 类型，因为带有空格和<code>*</code>字符，无法直接在函数名中表示，所以单独写一个实现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>*		LPSTR;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">char</span>* LPCSTR;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用模板</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_ADD(type) type my_add_##type(type x, type y) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">	return ((x) + (y)); \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为char*类型单独写一个实现</span></span><br><span class="line"><span class="function">LPSTR <span class="title">my_add_LPSTR</span><span class="params">(LPSTR x, LPSTR y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span>* pBuf = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(x) + <span class="built_in">strlen</span>(y) + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(pBuf, x);</span><br><span class="line">	<span class="built_in">strcat</span>(pBuf, y);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pBuf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD(type) my_add_##type</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于模板实例化</span></span><br><span class="line"><span class="built_in">DEF_ADD</span>(<span class="type">int</span>);</span><br><span class="line"><span class="built_in">DEF_ADD</span>(<span class="type">float</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">ADD</span>(<span class="type">int</span>)(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">ADD</span>(<span class="type">float</span>)(<span class="number">1.0f</span>, <span class="number">2.2f</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">ADD</span>(<span class="type">int</span>)(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span>* p = <span class="built_in">ADD</span>(LPSTR)((LPSTR)<span class="string">&quot;hello&quot;</span>, (LPSTR)<span class="string">&quot; wolrd&quot;</span>);</span><br><span class="line">	cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span>[] p;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>类</title>
    <url>/2022/11/24/%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>面向对象编程思想是为了解决什么问题？</p>
<ul>
<li>提高代码复用率（通用性）</li>
</ul>
<p>面向对象编程的三个核心概念：封装、继承、多态。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装就是通过<strong>访问权限关键字</strong>对成员变量和成员函数的访问权限进行限制。</p>
<h2 id="访问权限关键字"><a href="#访问权限关键字" class="headerlink" title="访问权限关键字"></a>访问权限关键字</h2><p><strong>public（公有）</strong>：类外可以对其直接访问。</p>
<p><strong>private（私有）</strong>：类外无法对其进行访问。</p>
<p><strong>protected（保护）</strong>：</p>
<h3 id="访问权限控制是语法限制"><a href="#访问权限控制是语法限制" class="headerlink" title="访问权限控制是语法限制"></a>访问权限控制是语法限制</h3><p>访问权限控制只是语法层面上的限制。可以通过指针来修改类中无法访问的成员变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetX</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_nX;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetX</span><span class="params">(<span class="type">int</span> nX)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_nX = nX;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nX;</span><br><span class="line">	<span class="type">int</span> m_nY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CPoint point;</span><br><span class="line">	point.<span class="built_in">SetX</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	*(<span class="type">int</span>*)&amp;point = <span class="number">999</span>;</span><br><span class="line">	cout &lt;&lt; point.<span class="built_in">GetX</span>() &lt;&lt; endl;	<span class="comment">// 输出999</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><h3 id="this-指针和-thiscall"><a href="#this-指针和-thiscall" class="headerlink" title="this 指针和 __thiscall"></a>this 指针和 __thiscall</h3><p>类的成员函数默认会有一个 this 指针参数，作为成员函数的<strong>第一个参数</strong>。</p>
<p>this 指针是指向类变量的指针，由编译器传入，指针名为 this。</p>
<p>this 指针是<strong>通过 ecx 寄存器来传递</strong>的。这种通过 ecx 传入 this 指针的调用约定叫做 <code>__thiscall</code>。</p>
<p><code>__thiscall</code> 只能用在成员函数上。</p>
<h3 id="修改成员函数的调用约定"><a href="#修改成员函数的调用约定" class="headerlink" title="修改成员函数的调用约定"></a>修改成员函数的调用约定</h3><p>成员函数默认是使用 <code>__thiscall</code> 调用约定。</p>
<p>成员函数的调用约定是可以修改的，但是不建议进行修改。</p>
<p>修改调用约定后，编译器会默认将 this 指针作为参数列表最左边的参数根据修改后的调用约定进行传参。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetX</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_nX;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> __cdecl <span class="title">SetX</span><span class="params">(<span class="type">int</span> nX)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_nX = nX;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nX;</span><br><span class="line">	<span class="type">int</span> m_nY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CPoint point;</span><br><span class="line"></span><br><span class="line">	point.<span class="built_in">SetX</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下图是调用 <code>SetX</code> 函数时的栈结构，可以看见 this 指针是通过栈进行传递的。因为 <code>__cdecl</code> 是从右往左进行传参，所以参数 100 先入栈，然后才是 this 指针。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/%E7%B1%BB.assets/image-20201218101258845.png"
                      alt="image-20201218101258845"
                ></p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>类中 <code>public</code> 属性的成员函数，也被叫作<strong>接口</strong>。</p>
<h2 id="class-和-struct"><a href="#class-和-struct" class="headerlink" title="class 和 struct"></a>class 和 struct</h2><p>在C++中，<strong>struct</strong> 和 <strong>class</strong> 基本是一样的。<strong>struct</strong> 中也可以定义成员函数。</p>
<p><strong>class</strong> 的默认访问权限 <strong>private</strong>。<strong>struct</strong> 的默认访问权限是 <strong>public</strong>。</p>
<p><strong>class</strong> 成员变量的对齐规则与 <strong>struct</strong> 成员变量的对齐规则是一致的。（没有虚函数的情况下）</p>
<h2 id="空类的-size"><a href="#空类的-size" class="headerlink" title="空类的 size"></a>空类的 size</h2><p>没有任何成员变量的 class 的大小是 1 字节。这 1 字节是用来占位的。</p>
<h2 id="成员函数指针"><a href="#成员函数指针" class="headerlink" title="成员函数指针"></a>成员函数指针</h2><h3 id="定义和赋值"><a href="#定义和赋值" class="headerlink" title="定义和赋值"></a>定义和赋值</h3><p>定义成员函数指针类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> 返回值类型 (类名::*指针类型名)(参数列表);</span><br></pre></td></tr></table></figure>

<p>成员函数指针的赋值必须使用 <code>&amp;</code> 符号：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">指针类型名  指针名 = &amp;类名::成员函数名;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetX</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_nX;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetX</span><span class="params">(<span class="type">int</span> nX)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_nX = nX;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nX;</span><br><span class="line">	<span class="type">int</span> m_nY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(CPoint::*PFN_SETX)</span><span class="params">(<span class="type">int</span> n)</span></span>; <span class="comment">// 定义成员函数指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CPoint point;</span><br><span class="line"></span><br><span class="line">	PFN_SETX pfnSetX = &amp;CPoint::SetX;  <span class="comment">// 为成员函数指针赋值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>成员函数指针不能直接使用。<code>pfnSetX(100)</code>，像这样直接通过成员函数直接来调用的话，编译器会报错。因为这个成员函数本质上应该是有两个参数的（需要 this 指针），像这样直接调用的话，就没有了 this 指针参数。</p>
<h4 id="通过类对象使用"><a href="#通过类对象使用" class="headerlink" title="通过类对象使用"></a>通过类对象使用</h4><p>通过类对象使用函数指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(对象名.*指针名)(参数列表);</span><br></pre></td></tr></table></figure>

<p>例子:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetX</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_nX;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetX</span><span class="params">(<span class="type">int</span> nX)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_nX = nX;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nX;</span><br><span class="line">	<span class="type">int</span> m_nY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(CPoint::*PFN_SETX)</span><span class="params">(<span class="type">int</span> n)</span></span>; <span class="comment">// 定义成员函数指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CPoint point;</span><br><span class="line"></span><br><span class="line">	PFN_SETX pfnSetX = &amp;CPoint::SetX;  <span class="comment">// 为成员函数指针赋值</span></span><br><span class="line">	(point.*pfnSetX)(<span class="number">50</span>);  <span class="comment">// 通过类对象使用函数指针</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过类对象指针使用"><a href="#通过类对象指针使用" class="headerlink" title="通过类对象指针使用"></a>通过类对象指针使用</h4><p>通过类对象指针使用成员函数指针:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(类对象指针名-&gt;*成员函数指针名)(参数列表);</span><br></pre></td></tr></table></figure>

<p>例子:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetX</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_nX;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetX</span><span class="params">(<span class="type">int</span> nX)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_nX = nX;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nX;</span><br><span class="line">	<span class="type">int</span> m_nY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(CPoint::*PFN_SETX)</span><span class="params">(<span class="type">int</span> n)</span></span>; <span class="comment">// 定义成员函数指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CPoint point;</span><br><span class="line">	CPoint* p = &amp;point;</span><br><span class="line"></span><br><span class="line">	PFN_SETX pfnSetX = &amp;CPoint::SetX;  <span class="comment">// 为成员函数指针赋值</span></span><br><span class="line">	(p-&gt;*pfnSetX)(<span class="number">666</span>);  <span class="comment">// 通过类对象指针使用函数指针</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="类对象共享成员函数"><a href="#类对象共享成员函数" class="headerlink" title="类对象共享成员函数"></a>类对象共享成员函数</h2><p>同一个类实例化的不同类对象之间，成员变量各自独享，成员函数共享。</p>
<p>成员函数的位置和全局函数的位置一样。</p>
<h2 id="类的声明和实现分开"><a href="#类的声明和实现分开" class="headerlink" title="类的声明和实现分开"></a>类的声明和实现分开</h2><p>类的声明可以写在头文件中，实现写在 cpp 文件中。在 cpp 中写类的实现时，要加上类名和作用域运算符。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">CPoint::SetX</span><span class="params">(<span class="type">int</span> nX)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_nX = nX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类声明，一般将公有成员函数放最前面，然后是私有函数，私有成员。</p>
<ul>
<li>因为公有函数都是提供给外部使用的接口。当别人使用你的类时，他们只关心能使用的外部接口。所以将公有成员函数放在前面可以让别人更容易看到。</li>
</ul>
<h2 id="构造和析构"><a href="#构造和析构" class="headerlink" title="构造和析构"></a>构造和析构</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p><strong>构造函数</strong>是类的一个成员函数，<strong>函数名和类名相同</strong>，<strong>无返回值</strong>，<strong>可以重载</strong>。一般构造函数都是 <strong>public</strong> 权限，但是也可以声明为 <strong>private</strong> 和 <strong>protected</strong>。</p>
<p><strong>自动调用时机</strong>：在对象被创建时（对象的生命周期开始时）会自动调用构造函数。</p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CPoint</span>()  <span class="comment">// 构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;CPoint::CPoint()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">CPoint</span>(<span class="type">int</span> nX)  <span class="comment">// 构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;CPoint::CPoint(int nX)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nX;</span><br><span class="line">	<span class="type">int</span> m_nY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CPoint pt1;</span><br><span class="line">	<span class="function">CPoint <span class="title">pt2</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;main()&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CPoint::CPoint()</span><br><span class="line">CPoint::CPoint(int nX)</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>



<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p><strong>析构函数</strong>是类的一个成员函数，<strong>函数名和类名相同</strong>，前面有一个 <code>~</code> 符号。析构函数<strong>无返回值</strong>，<strong>无参数</strong>，<strong>不能重载</strong>。</p>
<p><strong>自动调用时机</strong>：在对象的生命周期结束时调用析构函数（<strong>delete</strong> 释放一个对象时，也会调用析构函数）。</p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CPoint</span>()  <span class="comment">// 构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;CPoint::CPoint()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">CPoint</span>() <span class="comment">// 析构函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;CPoint::~CPoint()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nX;</span><br><span class="line">	<span class="type">int</span> m_nY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CPoint pt1;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;main()&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CPoint::CPoint()</span><br><span class="line">main()</span><br><span class="line">CPoint::~CPoint()</span><br></pre></td></tr></table></figure>



<h3 id="显式调用构造和析构"><a href="#显式调用构造和析构" class="headerlink" title="显式调用构造和析构"></a>显式调用构造和析构</h3><p>显式调用构造函数： <code>对象名.类名::构造函数名()</code></p>
<p>显式调用析构函数：<code>对象名.析构函数名()</code></p>
<p><strong>注意</strong>：强烈不建议手动调用构造函数和析构函数。</p>
<p>例子:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CPoint</span>()  <span class="comment">// 构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;CPoint::CPoint()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">CPoint</span>() <span class="comment">// 析构函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;CPoint::~CPoint()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nX;</span><br><span class="line">	<span class="type">int</span> m_nY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CPoint pt1;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;main()&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;start&quot;</span> &lt;&lt; endl;</span><br><span class="line">	pt1.CPoint::<span class="built_in">CPoint</span>();  <span class="comment">// 显式调用构造函数</span></span><br><span class="line">	pt1.~<span class="built_in">CPoint</span>();         <span class="comment">// 显式调用析构函数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;endl&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CPoint::CPoint()</span><br><span class="line">main()</span><br><span class="line">start</span><br><span class="line">CPoint::CPoint()</span><br><span class="line">CPoint::~CPoint()</span><br><span class="line">endl</span><br><span class="line">CPoint::~CPoint()</span><br></pre></td></tr></table></figure>



<h3 id="私有的构造和析构"><a href="#私有的构造和析构" class="headerlink" title="私有的构造和析构"></a>私有的构造和析构</h3><p>将构造和析构设为私有成员可以限制类对象的创建，使其无法随意创建对象，只能通过类提供的方法来进行创建和销毁。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CFoo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> CFoo* <span class="title">Create</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">CFoo</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Destroy</span><span class="params">(CFoo* p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">CFoo</span>() &#123;&#125;;</span><br><span class="line">    ~<span class="built_in">CFoo</span>() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    CFoo* pFoo = CFoo::<span class="built_in">Create</span>();</span><br><span class="line">    <span class="comment">// 销毁对象</span></span><br><span class="line">    CFoo::<span class="built_in">Destroy</span>(pFoo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="默认构造（缺省构造、无参构造）"><a href="#默认构造（缺省构造、无参构造）" class="headerlink" title="默认构造（缺省构造、无参构造）"></a>默认构造（缺省构造、无参构造）</h2><ul>
<li><strong>如果类没有实现构造函数，编译器会提供一个默认构造。</strong></li>
<li><strong>只要类有实现一个构造函数，编译器就不再为类提供默认构造。</strong></li>
</ul>
<p>编译器也会偷懒，并不是任何情况下都会实现默认构造。</p>
<p>编译器提供默认构造的情况：</p>
<ul>
<li><strong>父类有实现默认构造，子类没有实现构造函数，编译器会为子类实现一个默认构造。</strong></li>
<li><strong>类中的对象成员有实现默认构造，自己没有实现构造函数，编译器会为类实现一个默认构造。</strong></li>
<li><strong>类中有虚函数，且没有实现构造函数，编译器会为类实现一个默认构造。</strong></li>
</ul>
<p>析构也是类似的，有必要的时候，编译器才会为类实现一个默认析构函数。</p>
<h2 id="不同的创建对象方式"><a href="#不同的创建对象方式" class="headerlink" title="不同的创建对象方式"></a>不同的创建对象方式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 构造函数</span></span><br><span class="line">	<span class="built_in">CPoint</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;CPoint::CPoint()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">CPoint</span>(<span class="type">int</span> nX)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;CPoint::CPoint(int nX)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">CPoint</span>(<span class="type">int</span> nX, <span class="type">int</span> nY)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;CPoint::CPoint(int nX, int nY)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">CPoint</span>() <span class="comment">// 析构函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;CPoint::~CPoint()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nX;</span><br><span class="line">	<span class="type">int</span> m_nY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// CPoint()</span></span><br><span class="line">	CPoint pt1;</span><br><span class="line">	CPoint pt2&#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// CPoint(int nX)</span></span><br><span class="line">	<span class="function">CPoint <span class="title">pt3</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	CPoint pt4&#123; <span class="number">1</span> &#125;;</span><br><span class="line">	CPoint pt5 = <span class="number">1</span>;</span><br><span class="line">	CPoint pt6 = &#123; <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// CPoint(int nX, int nY)</span></span><br><span class="line">	<span class="function">CPoint <span class="title">pt7</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">	CPoint pt8&#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">	CPoint pt9 = &#123; <span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="拷贝构造（复制构造）"><a href="#拷贝构造（复制构造）" class="headerlink" title="拷贝构造（复制构造）"></a>拷贝构造（复制构造）</h2><p>拷贝构造：</p>
<ul>
<li>当类没有实现拷贝构造的时候，编译器会提供一个默认的拷贝构造。默认的拷贝构造只进行内存拷贝的操作。</li>
<li>当类自己提供了拷贝构造的时候，则调用提供的拷贝构造。</li>
</ul>
<h3 id="为什么要实现拷贝构造"><a href="#为什么要实现拷贝构造" class="headerlink" title="为什么要实现拷贝构造"></a>为什么要实现拷贝构造</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CDataBuff</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CDataBuff</span>(<span class="type">const</span> <span class="type">char</span>* pszStr)</span><br><span class="line">	&#123;</span><br><span class="line">		m_uSize = <span class="built_in">strlen</span>(pszStr) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		m_pBuf = <span class="keyword">new</span> <span class="type">char</span>[m_uSize];</span><br><span class="line">		<span class="built_in">memcpy</span>(m_pBuf, pszStr, m_uSize);</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">CDataBuff</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_pBuf != <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span>[] m_pBuf;</span><br><span class="line">		&#125;</span><br><span class="line">		m_uSize = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span>* m_pBuf;</span><br><span class="line">	<span class="type">size_t</span> m_uSize;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">(CDataBuff buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">CDataBuff <span class="title">buf1</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Foo</span>(buf1);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码在执行时将会出错。</p>
<p>在<code>Foo</code>函数进行传参时，是直接进行值传递的。也就是类似于 <code>memcpy(buf, buf1, sizeof(CDatabuff))</code>。<code>buf.m_pBuf</code>的的值和<code>buf1.m_pBuf</code>中的值是一样的，指向的是同一个堆块地址。</p>
<p>当<code>Foo</code>函数结束时，要对执行<code>buf</code>对象的析构函数。析构函数中将<code>buf.m_pBuf</code>所指向的堆块给释放了，也就是把<code>buf1.m_pBuf</code>指向的堆块给释放了。</p>
<p>那么当<code>main</code>函数结束时，调用<code>buf1</code>的析构函数对<code>buf1.m_pBuf</code>进行释放就会产生错误。因为这个堆块已经被释放了。</p>
<hr>
<p>为了解决上面这个问题，就需要实现拷贝构造函数。当对象进行拷贝操作时，就会调用拷贝构造，而不是直接进行内存复制。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CDataBuff</span>(<span class="type">const</span> CDataBuff&amp; buf)</span><br><span class="line">&#123;</span><br><span class="line">    m_pBuf = <span class="keyword">new</span> <span class="type">char</span>[buf.m_uSize];</span><br><span class="line">    <span class="built_in">memcpy</span>(m_pBuf, buf.m_pBuf, buf.m_uSize);</span><br><span class="line"></span><br><span class="line">    m_uSize = buf.m_uSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拷贝构造的参数是引用类型"><a href="#拷贝构造的参数是引用类型" class="headerlink" title="拷贝构造的参数是引用类型"></a>拷贝构造的参数是引用类型</h3><p>如果拷贝构造的参数不是引用或指针类型，而是下面这样:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CDataBuff</span>(<span class="type">const</span> CDataBuff buf)</span><br><span class="line">&#123;</span><br><span class="line">    m_pBuf = <span class="keyword">new</span> <span class="type">char</span>[buf.m_uSize];</span><br><span class="line">    <span class="built_in">memcpy</span>(m_pBuf, buf.m_pBuf, buf.m_uSize);</span><br><span class="line"></span><br><span class="line">    m_uSize = buf.m_uSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时就会出现一个死循环的问题。</p>
<p>在调用上面这个拷贝构造函数时，就需要传入<code>CDataBuff</code>的对象。也就是把<code>CDataBuff</code>的对象拷贝到了函数栈空间中。而这个拷贝的过程是需要调用拷贝构造函数的，那么就会陷入一个死循环。（在调用拷贝构造函数时需要传参，而传参时需要拷贝，拷贝需要调用拷贝构造函数，调用函数又需要传参……于是就陷入一个死循环）</p>
<h3 id="调用拷贝构造的时机"><a href="#调用拷贝构造的时机" class="headerlink" title="调用拷贝构造的时机"></a>调用拷贝构造的时机</h3><p>调用拷贝构造的时机：</p>
<ul>
<li><p>对象传参。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">(CDataBuf buf)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用对象初始化另一个对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CDataBuff buf0;</span><br><span class="line"><span class="function">CDataBuff <span class="title">buf1</span><span class="params">(buf0)</span></span>;	<span class="comment">// 调用拷贝构造函数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>返回值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">CDataBuf <span class="title">Foo</span><span class="params">()</span></span>;  <span class="comment">// 返回一个对象时，会调用拷贝构造创建一个无名对象</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h2><p>const成员函数：</p>
<ul>
<li><p>本质上就是对 <code>this</code> 指针加一个底层<code>const</code>修饰，使得函数内部无法通过<code>this</code>指针来对成员变量进行修改。一般成员的<code>this</code>指针类型是<code>type* const this</code>。常成员函数的<code>this</code>指针类型是<code>const type* const this</code>。</p>
</li>
<li><p>const成员函数不能修改成员变量，不能调用一般的成员函数，只能调用const成员函数。</p>
<ul>
<li>因为const成员函数中的<code>this</code>指针存在底层<code>const</code>属性，而一般成员函数的指针没有底层<code>const</code>属性，所以无法接收它的<code>this</code>指针作为参数。</li>
</ul>
</li>
<li><p>不能修改和不能调用仅是语法层面的限制。可以通过强转绕过限制。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">((CFoo*)<span class="keyword">this</span>)-&gt;m_nData = <span class="number">99</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常成员函数适用于 <code>GetXXXX</code> 之类的只读不修改数据的成员函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetData</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_nData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="列表化列表（List-initialization）"><a href="#列表化列表（List-initialization）" class="headerlink" title="列表化列表（List-initialization）"></a>列表化列表（List-initialization）</h2><p>列表初始化：</p>
<ul>
<li><p>可以对成员(一般的数据成员，常量数据成员，类对象成员)进行初始化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CTest</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CTest</span>(<span class="type">int</span> n1, <span class="type">int</span> n2) </span><br><span class="line">        :<span class="built_in">m_n1</span>(n1), <span class="built_in">m_n2</span>(n2)   <span class="comment">// 列表初始化</span></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_n1;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> m_n2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>列表初始化的执行时机要比构造函数的函数体早。</p>
</li>
<li><p>列表初始化对成员初始化的顺序是按照成员在类中的定义顺序，与列表初始化的书写顺序无关。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CTest1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CTest1</span>(<span class="type">int</span> n)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;CTest1::CTest1(): &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CTest2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CTest2</span>(<span class="type">int</span> n1, <span class="type">int</span> n2)</span><br><span class="line">		:<span class="built_in">test2</span>(n2), <span class="built_in">test1</span>(n1)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	CTest1 test1;</span><br><span class="line">	CTest1 test2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">CTest2 <span class="title">test</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CTest1::CTest1(): 1</span><br><span class="line">CTest1::CTest1(): 2</span><br></pre></td></tr></table></figure>
</li>
<li><p>声明和实现分开时，列表初始化放在实现中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CTest</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CTest</span>(<span class="type">int</span> n1, <span class="type">int</span> n2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_n1;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> m_n2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CTest::<span class="built_in">CTest</span>(<span class="type">int</span> n1, <span class="type">int</span> n2)</span><br><span class="line">	:<span class="built_in">m_n1</span>(n1), <span class="built_in">m_n2</span>(n2)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="类对象和对象成员的构造时机"><a href="#类对象和对象成员的构造时机" class="headerlink" title="类对象和对象成员的构造时机"></a>类对象和对象成员的构造时机</h2><p>类中对象成员的构造函数执行时间早于该类对象的构造函数。</p>
<p>多个对象成员之间，按照定义的顺序执行构造函数。</p>
<p>析构的顺序与构造的顺序相反。</p>
<p>存在继承时的构造顺序：</p>
<ul>
<li>父类构造函数</li>
<li>子类成员变量构造函数</li>
<li>子类构造函数</li>
</ul>
<h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><h3 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h3><ul>
<li><p>声明和实现必须分开，实现不加<code>static</code>关键字。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CTest</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CTest</span>(<span class="type">int</span> n)</span><br><span class="line">	&#123;</span><br><span class="line">		m_n1 = n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_n1;  <span class="comment">// 声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> CTest::m_n1;  <span class="comment">// 实现</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>静态成员变量是存储在全局数据区的。<code>sizeof</code>计算类的大小时，不会计算静态成员变量的大小。</p>
</li>
<li><p>静态成员变量不属于某个对象，属于类。所以可以直接通过<code>类名::静态成员名</code>来访问静态成员变量。所有对象共享静态成员变量。</p>
</li>
<li><p>静态成员变量和全局变量的生命周期一样（与程序同生共死）。</p>
</li>
</ul>
<h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><ul>
<li><p>声明和实现必须分开，实现不加<code>static</code>关键字。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CTest</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CTest</span>(<span class="type">int</span> n)</span><br><span class="line">	&#123;</span><br><span class="line">		m_n1 = n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">GetVal</span><span class="params">()</span></span>; <span class="comment">// 声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_n1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> CTest::m_n1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CTest::GetVal</span><span class="params">()</span>  <span class="comment">// 实现</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> m_n1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不能访问非静态成员。静态成员函数是没有<code>this</code>指针参数的，所以无法访问非静态成员。</p>
</li>
<li><p>可以通过<code>类名::静态成员函数名</code>直接访问静态成员函数。</p>
</li>
</ul>
<h2 id="explicit关键字"><a href="#explicit关键字" class="headerlink" title="explicit关键字"></a>explicit关键字</h2><h3 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="headerlink" title="隐式的类类型转换"></a>隐式的类类型转换</h3><p>C++中，如果构造函数可以<strong>只接受一个实参</strong>，则它实际上定义了转换为此类类型的隐式转换机制，有时把这种构造函数称为<strong>转换构造函数（converting constructor）</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">const</span> <span class="type">char</span> data)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt;<span class="string">&quot;constructor...&quot;</span> &lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="type">char</span> m_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">base1</span><span class="params">(<span class="string">&#x27;a&#x27;</span>)</span></span>;        <span class="comment">// 用于构建单参数的类对象</span></span><br><span class="line">    Base base2 = <span class="string">&#x27;b&#x27;</span>;     <span class="comment">// 隐含的类型转换操作符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，<code>Base base2 = &#39;b&#39;;</code>这条语句就是先将字符<code>b</code>通过构造函数隐式转换为一个<code>Base</code>类的对象。</p>
<p>有时我们不希望进行这种隐式转换，就可以使用关键字 <strong>explicit</strong> 来进行限制。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Base</span><span class="params">(<span class="type">const</span> <span class="type">char</span> data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt;<span class="string">&quot;constructor...&quot;</span> &lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="type">char</span> m_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">base1</span><span class="params">(<span class="string">&#x27;a&#x27;</span>)</span></span>;        <span class="comment">// 用于构建单参数的类对象</span></span><br><span class="line">    Base base2 = <span class="string">&#x27;b&#x27;</span>;     <span class="comment">// 报错，无法从&#x27;char&#x27;转换为&#x27;Base&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="禁用默认的成员函数"><a href="#禁用默认的成员函数" class="headerlink" title="禁用默认的成员函数"></a>禁用默认的成员函数</h2><p>类中有一些默认的成员函数，如果没有定义，编译器就会自动生成。</p>
<ul>
<li>默认构造函数</li>
<li>默认析构函数</li>
<li>拷贝构造函数</li>
<li>拷贝赋值函数</li>
<li>移动拷贝函数</li>
<li>移动赋值函数</li>
</ul>
<p>有的时候我们没有定义某些默认函数，也不希望编译器自动生成这些函数，就可以使用<code>=delete</code>禁用掉这些函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() = <span class="keyword">delete</span>;  <span class="comment">// 删除掉默认构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        m_data = n;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> m_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">base1</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line">    Base base2;  <span class="comment">// 报错，Base的默认构造函数已被删除</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>类的内存结构</title>
    <url>/2022/11/24/%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="没有虚继承"><a href="#没有虚继承" class="headerlink" title="没有虚继承"></a>没有虚继承</h2><h3 id="单个类"><a href="#单个类" class="headerlink" title="单个类"></a>单个类</h3><p>就类似于结构体的内存结构。</p>
<h3 id="单个类，有虚函数"><a href="#单个类，有虚函数" class="headerlink" title="单个类，有虚函数"></a>单个类，有虚函数</h3><p>与单个类的内存结构基本一样，只是在一开始多了一个虚表指针。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.assets/image-20210103160310180.png"
                      alt="image-20210103160310180"
                ></p>
<h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><p>相当于将两个类的成员合在一起。先是父类成员，然后是子类成员。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.assets/image-20210103160535142.png"
                      alt="image-20210103160535142"
                ></p>
<h3 id="单继承，有虚函数"><a href="#单继承，有虚函数" class="headerlink" title="单继承，有虚函数"></a>单继承，有虚函数</h3><p>和单继承的内存结构基本一样，只是在一开始多了一个虚表指针。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.assets/image-20210103221125752.png"
                      alt="image-20210103221125752"
                ></p>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>按照继承顺序，先继承的父类成员在前，后继承的父类成员在后，最后是子类的成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> :<span class="keyword">public</span> A, <span class="keyword">public</span> B &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.assets/image-20210103174323763.png"
                      alt="image-20210103174323763"
                ></p>
<h3 id="多重继承，有虚函数"><a href="#多重继承，有虚函数" class="headerlink" title="多重继承，有虚函数"></a>多重继承，有虚函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">TestA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;A::TestA()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nA = <span class="number">0x11111111</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">TestB</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;B::TestB()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nB = <span class="number">0x22222222</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> :<span class="keyword">public</span> A, <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">TestB</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;C::TestB()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">TestC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;C::TestC()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nC = <span class="number">0x33333333</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，C 的对象的内存结构如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.assets/image-20210103222453112.png"
                      alt="image-20210103222453112"
                ></p>
<p>从上图可以看出，子类不仅继承了父类的成员，如果父类有虚函数，还会继承父类的虚表，所以子类中可能存在多个虚表指针。</p>
<p><strong>注意1</strong>：如果子类重写了父类的虚函数，子类重写的函数地址将会覆盖从该父类继承的虚表中的对应项。</p>
<p><strong>注意2</strong>：如果子类新增了虚函数，新增的虚函数地址将会放到第一个虚表指针所指向的虚表中。</p>
<p><strong>注意3</strong>：如果继承的父类没有虚函数，则在内存中，后面有虚函数的父类对象会提前。下面会举个例子来说明这一点。</p>
<p><strong>注意4</strong>：如果父类没有虚函数，则父类没有虚表，子类也就不会继承它的虚表。</p>
<p>以上面的代码为例，将 class A 改为下面这样，其他不变：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nA = <span class="number">0x11111111</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么 C 对象的内存结构就会变成下面这样：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.assets/image-20210103224118772.png"
                      alt="image-20210103224118772"
                ></p>
<p>内存中，按照继承顺序，本来 A 对象应该在前。结果因为 A 没有虚函数，B 对象被提前，A 对象被放到了后面。</p>
<h2 id="有虚继承"><a href="#有虚继承" class="headerlink" title="有虚继承"></a>有虚继承</h2><h3 id="单虚继承"><a href="#单虚继承" class="headerlink" title="单虚继承"></a>单虚继承</h3><p>与单继承相比，单虚继承的派生类对象的内存中多了一个偏移表指针，并且虚基类的成员会被放到后面。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nA = <span class="number">0x11111111</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nB = <span class="number">0x22222222</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>B 对象的内存结构如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.assets/image-20210103225514885.png"
                      alt="image-20210103225514885"
                ></p>
<p>因为类中没有虚表指针，所以与虚表指针的偏移是 0。</p>
<h3 id="单虚继承，有虚函数"><a href="#单虚继承，有虚函数" class="headerlink" title="单虚继承，有虚函数"></a>单虚继承，有虚函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">TestA</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nA = <span class="number">0x11111111</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">TestB</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nB = <span class="number">0x22222222</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>B 对象的内存结构如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.assets/image-20210103230829481.png"
                      alt="image-20210103230829481"
                ></p>
<p><strong>注意1</strong>：如果父类没有虚函数，则父类没有虚表。</p>
<ul>
<li>对象的内存结构中就不会有<code>A::__vfptr</code>。因为只有当类存在虚函数时，类对象中才会有虚表指针。</li>
</ul>
<p><strong>注意2</strong>：子类重写的虚函数会覆盖父类虚表中的对应项。子类新增的虚函数，会放到子类自己的虚表中。</p>
<p><strong>注意3</strong>：如果子类没有新增虚函数，那么子类没有自己的虚表。</p>
<ul>
<li>也就是说 B 的内存结构中，没有了<code>B::__vfptr</code>，第一个成员变成了<code>偏移表指针</code>。</li>
</ul>
<h3 id="菱形继承，没有虚函数"><a href="#菱形继承，没有虚函数" class="headerlink" title="菱形继承，没有虚函数"></a>菱形继承，没有虚函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nA = <span class="number">0x11111111</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nB = <span class="number">0x22222222</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nC = <span class="number">0x33333333</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nD = <span class="number">0x44444444</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>D 对象的内存结构如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.assets/image-20210103233106279.png"
                      alt="image-20210103233106279"
                ></p>
<p>虚基类的成员被放到最后。每个父类对象都有一个偏移表指针。</p>
<p><strong>父类对象的偏移表中，第一个成员记录的是该父类的偏移表指针到该父类虚表指针的偏移；第二个成员记录的是该父类的偏移表指针到基类对象的偏移。</strong></p>
<h3 id="菱形继承，有虚函数"><a href="#菱形继承，有虚函数" class="headerlink" title="菱形继承，有虚函数"></a>菱形继承，有虚函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">TestA</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nA = <span class="number">0x11111111</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">TestB</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nB = <span class="number">0x22222222</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">TestC</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nC = <span class="number">0x33333333</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">TestA</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">TestD</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nD = <span class="number">0x44444444</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>D 对象的内存结构如下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.assets/image-20210103234934745.png"
                      alt="image-20210103234934745"
                ></p>
<p><strong>注意1</strong>：如果父类没有虚函数，则没有父类的虚表。</p>
<p><strong>注意2</strong>：子类重写的虚函数，会覆盖父类虚表中的对应项。</p>
<p><strong>注意3</strong>：子类新增的虚函数，会放到第一个虚表中，也就是子类自己的虚表。</p>
<p><strong>注意4</strong>：与多重继承类似，没有虚函数的父类会被放到后面，有虚函数的父类会被提前。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>结构体</title>
    <url>/2022/11/25/%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><h3 id="编译选项-x2F-Zp"><a href="#编译选项-x2F-Zp" class="headerlink" title="编译选项 &#x2F;Zp"></a>编译选项 &#x2F;Zp</h3><p><code>/Zp</code>：该编译选项可以修改编译对齐值，默认为<code>8</code>字节。使用方法如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/Zp2	修改对齐值为2字节</span><br></pre></td></tr></table></figure>

<h3 id="对齐规则"><a href="#对齐规则" class="headerlink" title="对齐规则"></a>对齐规则</h3><ol>
<li><p>设编译对齐值为<code>Zp</code>，结构体成员的内部偏移量为<code>offset</code>，结构体成员的类型为<code>member type</code>。<code>offset</code>必须满足下面的条件：</p>
<ul>
<li><p><code>offset % min(Zp, sizeof(member type)) == 0</code></p>
</li>
<li><p>注意：如果成员是数组，比如<code>char ary[4]</code>，<code>member type</code>指的是每个元素的类型，也就是<code>char</code>，而不是<code>char [4]</code></p>
</li>
</ul>
</li>
<li><p>设结构体整体对齐值为<code>Align</code>，必须满足：</p>
<ul>
<li><code>Align = min(Zp, max(sizeof(member1 type), sizeof(member2 type), sizeof(member3 type)...))</code></li>
</ul>
</li>
<li><p>设结构体占用为<code>size</code>，必须满足：</p>
<ul>
<li><code>size % Align == 0</code></li>
</ul>
</li>
</ol>
<p><strong>注意</strong>：当结构体成员是结构体时，计算偏移的公式为<code>offset % min(Zp,  Align_member) == 0</code>。其中<code>Align_member</code>是该结构体成员的<code>Align</code>值。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/%E7%BB%93%E6%9E%84%E4%BD%93.assets/image-20220526001006255.png"
                      alt="image-20220526001006255"
                ></p>
<h3 id="修改内存对齐"><a href="#修改内存对齐" class="headerlink" title="修改内存对齐"></a>修改内存对齐</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(8)  <span class="comment">//将内存对齐改为8</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> c1;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">char</span> c2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()  <span class="comment">//还原为默认的内存对齐</span></span></span><br></pre></td></tr></table></figure>



<h2 id="计算结构体成员偏移的宏"><a href="#计算结构体成员偏移的宏" class="headerlink" title="计算结构体成员偏移的宏"></a>计算结构体成员偏移的宏</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(type, member)	(size_t)&amp;(((type*)0)-&gt;member)</span></span><br></pre></td></tr></table></figure>

<h2 id="结构体传参"><a href="#结构体传参" class="headerlink" title="结构体传参"></a>结构体传参</h2><p>当参数为结构体时，会将结构体复制一份，通过栈传递。所以当结构体的很大时，要使用传指针或传引用的方式进行传参。</p>
<h2 id="内部结构体的三种定义方式"><a href="#内部结构体的三种定义方式" class="headerlink" title="内部结构体的三种定义方式"></a>内部结构体的三种定义方式</h2><ol>
<li><p>在结构体外部定义，任何人都可以使用内部结构体类型<code>tagDateOfBirth</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagDateOfBirth</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> nYear;</span><br><span class="line">    <span class="type">int</span> nMonth;</span><br><span class="line">    <span class="type">int</span> nDay;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPerson</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> szName[<span class="number">32</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagDateOfBirth</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在结构体内部定义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPerson</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> szName[<span class="number">32</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagDateOfBirth</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">int</span> nYear;</span><br><span class="line">        <span class="type">int</span> nMonth;</span><br><span class="line">        <span class="type">int</span> nDay;</span><br><span class="line">    &#125;DOB;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以通过所属关系来使用内部结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPerson</span>:</span>:tagDateOfBirth dob = &#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在结构体内部定义无名结构体，别人就无法使用内部结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPerson</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> szName[<span class="number">32</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">int</span> nYear;</span><br><span class="line">        <span class="type">int</span> nMonth;</span><br><span class="line">        <span class="type">int</span> nDay;</span><br><span class="line">    &#125;DOB;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="位段"><a href="#位段" class="headerlink" title="位段"></a>位段</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPrivilege</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ADD:<span class="number">1</span>;	<span class="comment">// 定义一个无符号整数，只占1位（1bit）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> DEL:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> EDT:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> QUE:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagPrivilege</span> <span class="title">n</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    n.Add = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n.ADD == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;ADD&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将位运算交给编译器来处理。</p>
<p>位段在参与运算时，会根据前面的类型进行转换。无符号类型用0填充高位，有符号类型用符号位填充高位。</p>
<p>例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// qqqqqeeeedddaa</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPrivilege</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ADD:<span class="number">2</span>;	<span class="comment">// 2bit</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> DEL:<span class="number">3</span>;	<span class="comment">// 3bit</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> EDT:<span class="number">4</span>;	<span class="comment">// 4bit</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> QUE:<span class="number">5</span>;	<span class="comment">// 5bit</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPrivilege</span> <span class="title">n</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">n.ADD = <span class="number">10</span>; <span class="comment">// n.ADD = 2;</span></span><br><span class="line"><span class="comment">// 因为10的二进制是1010b，ADD只占2个bit，所以只取低2bit。</span></span><br></pre></td></tr></table></figure>



<h3 id="无名位段"><a href="#无名位段" class="headerlink" title="无名位段"></a>无名位段</h3><p>无名位段，占位但是不使用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// qqqqqeeee????????dddaa</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPrivilege</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ADD:<span class="number">2</span>;	<span class="comment">// 2bit</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> DEL:<span class="number">3</span>;	<span class="comment">// 3bit</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> : <span class="number">8</span>;	<span class="comment">// 8bit，无名位段</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> EDT:<span class="number">4</span>;	<span class="comment">// 4bit</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> QUE:<span class="number">5</span>;	<span class="comment">// 5bit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="0位段"><a href="#0位段" class="headerlink" title="0位段"></a>0位段</h3><p>0 位段，放弃当前对齐单位剩余的所有空间，从下一个对齐单位开始使用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPrivilege</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ADD:<span class="number">2</span>;	<span class="comment">// 2bit</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> DEL:<span class="number">3</span>;	<span class="comment">// 3bit</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> : <span class="number">0</span>;	</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> EDT:<span class="number">4</span>;	<span class="comment">// 4bit</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> QUE:<span class="number">5</span>;	<span class="comment">// 5bit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>0 位段后面的成员在下一个对齐处开始定义</p>
<h3 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h3><p>使用位段时要有说明注释</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// eeeedddaa </span></span><br><span class="line"><span class="comment">// e: EDI权限</span></span><br><span class="line"><span class="comment">// d: DEL权限</span></span><br><span class="line"><span class="comment">// a: ADD权限</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPrivilege</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ADD:<span class="number">2</span>;	<span class="comment">// 2bit</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> DEL:<span class="number">3</span>;	<span class="comment">// 3bit</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> EDT:<span class="number">4</span>;	<span class="comment">// 4bit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>继承</title>
    <url>/2022/11/24/%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h2 id="称呼"><a href="#称呼" class="headerlink" title="称呼"></a>称呼</h2><p>一般有两种称呼方式：</p>
<ul>
<li><p><code>C3DPoint</code><strong>继承自（inherit）</strong><code>CPoint</code>。</p>
<p><code>C3DPoint</code>被称为<strong>子类（child）</strong>。<code>CPoint</code>被称为<strong>父类（parent）</strong>。</p>
</li>
<li><p><code>CPoint</code><strong>派生出*（derived）</strong><code>C3DPoint</code>。</p>
<p><code>C3DPoint</code>被称为<strong>派生类（derive）</strong>。<code>CPoint</code>被称为<strong>基类（base）</strong>。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CPoint</span>(<span class="type">int</span> nX = <span class="number">0</span>, <span class="type">int</span> nY = <span class="number">0</span>) :<span class="built_in">m_nX</span>(nX), <span class="built_in">m_nY</span>(nY)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetX</span><span class="params">(<span class="type">int</span> nX)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetX</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetY</span><span class="params">(<span class="type">int</span> nY)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetY</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nX;</span><br><span class="line">	<span class="type">int</span> m_nY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C3DPoint</span> :<span class="keyword">public</span> CPoint</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">C3DPoint</span>(<span class="type">int</span> nX = <span class="number">0</span>, <span class="type">int</span> nY = <span class="number">0</span>, <span class="type">int</span> nZ = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetZ</span><span class="params">(<span class="type">int</span> nZ)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetZ</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nZ;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="继承的权限"><a href="#继承的权限" class="headerlink" title="继承的权限"></a>继承的权限</h2><h3 id="public（公有继承）"><a href="#public（公有继承）" class="headerlink" title="public（公有继承）"></a>public（公有继承）</h3><table>
<thead>
<tr>
<th align="center">父类成员的权限</th>
<th align="center">父类外部访问</th>
<th align="center">子类内部访问</th>
<th align="center">子类外部访问</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
</tr>
<tr>
<td align="center">private</td>
<td align="center">NO</td>
<td align="center">NO</td>
<td align="center">NO</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">NO</td>
<td align="center">YES</td>
<td align="center">NO</td>
</tr>
</tbody></table>
<p>例子:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> A;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> B;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        A = <span class="number">0</span>; <span class="comment">// 类内可以访问父类的public成员</span></span><br><span class="line">        <span class="comment">// B = 0; 类内无法访问父类的private成员</span></span><br><span class="line">        C = <span class="number">0</span>; <span class="comment">// 类内可以访问父类的protected成员</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derive derive;</span><br><span class="line"></span><br><span class="line">    derive.A = <span class="number">0</span>; <span class="comment">// 类外可以访问父类的public成员</span></span><br><span class="line">    <span class="comment">// derive.B = 0; 类外无法访问父类的private成员</span></span><br><span class="line">    <span class="comment">// derive.C = 0; 类外无法访问父类的protected成员</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="构造和析构的顺序"><a href="#构造和析构的顺序" class="headerlink" title="构造和析构的顺序"></a>构造和析构的顺序</h2><p>子类对象构造的顺序：父类 –&gt; 成员 –&gt; 自己</p>
<p>子类对象析构的顺序：自己 –&gt; 成员 –&gt; 父类</p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CFoo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CFoo</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;CFoo::CFoo()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">CFoo</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;CFoo::~CFoo()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base::Base()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Base</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base::~Base()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derive</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derive::Derive()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Derive</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derive::~Derive()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CFoo foo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derive derive;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Base::Base()</span><br><span class="line">CFoo::CFoo()</span><br><span class="line">Derive::Derive()</span><br><span class="line">Derive::~Derive()</span><br><span class="line">CFoo::~CFoo()</span><br><span class="line">Base::~Base()</span><br></pre></td></tr></table></figure>

<h2 id="子类的内存分布"><a href="#子类的内存分布" class="headerlink" title="子类的内存分布"></a>子类的内存分布</h2><p>无虚函数时，子类内存分布如下图所示。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/%E7%BB%A7%E6%89%BF.assets/image-20220820222953145.png"
                      alt="image-20220820222953145"
                ></p>
<h2 id="突破权限控制"><a href="#突破权限控制" class="headerlink" title="突破权限控制"></a>突破权限控制</h2><p>权限控制是语法限制，可以通过内存地址突破这个限制。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> A;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> B;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// B = 0; 类内无法直接访问父类的private成员</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过内存地址来修改父类的private成员</span></span><br><span class="line">        *((<span class="type">int</span>*)<span class="keyword">this</span> + <span class="number">1</span>) = <span class="number">55</span>; <span class="comment">// B = 55;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> D;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="父类与子类指针的转换"><a href="#父类与子类指针的转换" class="headerlink" title="父类与子类指针的转换"></a>父类与子类指针的转换</h2><p>子类转父类指针，安全。</p>
<p>父类转子类指针，不安全，可能会发生越界。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Base base;</span><br><span class="line">Derive derive;</span><br><span class="line"></span><br><span class="line">Base* pBase = &amp;derive; <span class="comment">// 安全</span></span><br><span class="line">Derive* pDerive = (Derive*)&amp;base <span class="comment">// 不安全</span></span><br></pre></td></tr></table></figure>

<h2 id="数据隐藏"><a href="#数据隐藏" class="headerlink" title="数据隐藏"></a>数据隐藏</h2><p>子类中存在与父类同名的成员时，会将父类中的同名成员隐藏起来。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base::Test()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base::Test(int n)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> A = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derive::Test()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> A = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derive derive;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子类中存在与父类同名的成员时，会将父类中的同名成员隐藏起来。</span></span><br><span class="line"></span><br><span class="line">    derive.<span class="built_in">Test</span>(); <span class="comment">// 调用子类的Test函数</span></span><br><span class="line">    <span class="comment">// derive.Test(1); 父类的Test函数被隐藏了，所以无法调用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果想调用父类的同名成员，需要手动指明</span></span><br><span class="line">    derive.Base::<span class="built_in">Test</span>(); <span class="comment">// 调用父类的Test函数</span></span><br><span class="line">    derive.Base::<span class="built_in">Test</span>(<span class="number">1</span>); <span class="comment">// 调用父类的Test函数</span></span><br><span class="line"></span><br><span class="line">    derive.A = <span class="number">10</span>; <span class="comment">// 为子类的成员A赋值</span></span><br><span class="line">    derive.Base::A = <span class="number">100</span>; <span class="comment">// 指明为父类的成员A赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就和函数重载是一个道理。函数重载的本质就是名称粉碎。子类实现了父类的同名成员函数<code>Test()</code>，那么子类中的<code>Test</code>与父类中的<code>Test</code>，二者粉碎后的名称肯定是不同的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?Test@Base@@QEAAXXZ   //父类Test的名称粉碎</span><br><span class="line">?Test@Derive@@QEAAXXZ   //子类Test的名称粉碎</span><br></pre></td></tr></table></figure>

<p>在使用重载函数时，编译器会调用参数类型最匹配的那一个函数。这也是同样的道理，当子类对象调用<code>Test()</code>时，传入的是子类对象的<code>this</code>指针，显然这与子类自己实现的<code>Test</code>的参数类型更加匹配。</p>
<p>同理，如果我们使用父类的指针指向子类对象，再通过指针调用<code>Test()</code>。由于此时传入的是父类的<code>this</code>指针，参数类型与父类的<code>Test</code>更加匹配，因此就会调用父类的<code>Test()</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Base* p = &amp;derive;</span><br><span class="line">p-&gt;<span class="built_in">Test</span>();  <span class="comment">// 输出 Base::Test()</span></span><br></pre></td></tr></table></figure>



<h2 id="类与类之间的关系"><a href="#类与类之间的关系" class="headerlink" title="类与类之间的关系"></a>类与类之间的关系</h2><p>继承：<strong>is-a</strong></p>
<p>组合：<strong>has-a</strong></p>
<blockquote>
<p><strong>优先使用组合关系</strong>。</p>
</blockquote>
<p>例子：</p>
<ul>
<li><p>继承关系：出租车是一辆车。其中车是父类，出租车是子类。</p>
</li>
<li><p>组合关系：笔记本有内存条。笔记本是类，内存条是笔记本的成员</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器</title>
    <url>/2022/11/24/%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<h2 id="获取迭代器"><a href="#获取迭代器" class="headerlink" title="获取迭代器"></a>获取迭代器</h2><p>和指针不一样，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员函数。比如，这些类型都拥有 <code>begin</code> 和 <code>end</code> 成员，其中 <strong>begin</strong> 负责返回指向第一个元素（或第一个字符）的迭代器，<strong>end</strong> 负责返回指向容器（或 string 对象）“尾元素的下一位置”的迭代器。<br>end 成员返回的迭代器常被称作<strong>尾后迭代器（off-the-end iterator）</strong>或者简称<strong>尾迭代器（end iterator）</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">auto</span> b = v.<span class="built_in">begin</span>();  <span class="comment">// b的类型是 std::vector&lt;int&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> e = v.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能进行读操作的迭代器，无法通过其修改元素</span></span><br><span class="line"><span class="keyword">auto</span> cb = v.<span class="built_in">cbegin</span>();  <span class="comment">// cb的类型是 std::vector&lt;int&gt;::const_iterator</span></span><br><span class="line"><span class="keyword">auto</span> ce = v.<span class="built_in">cend</span>();</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>如果容器为空，则 begin 和 end 返回的是同一个迭代器，都是尾迭代器。</strong></p>
</blockquote>
<h2 id="迭代器的运算"><a href="#迭代器的运算" class="headerlink" title="迭代器的运算"></a>迭代器的运算</h2><img  
                     lazyload
                     alt="image"
                     data-src="images/迭代器.assets/epub_33692196_319.jpeg"
                      alt="img" style="zoom:80%;" 
                >

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">auto</span> p = str.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> q = str.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">while</span> (p != q)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	++p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>vector 和 string 迭代器支持的运算</strong>：</p>
<img  
                     lazyload
                     alt="image"
                     data-src="images/迭代器.assets/epub_33692196_332.jpeg"
                      alt="img" style="zoom:67%;" 
                >

<h2 id="迭代器类型"><a href="#迭代器类型" class="headerlink" title="迭代器类型"></a>迭代器类型</h2><p>那些拥有迭代器的标准库类型使用 <strong>iterator</strong> 和 <strong>const_iterator</strong> 来表示迭代器的类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;       <span class="comment">// it 能读写 vector&lt;int&gt; 的元素</span></span><br><span class="line">string::iterator it2;           <span class="comment">// it2 能读写 string 对象中的字符</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator it3;    <span class="comment">// it3 只能读元素，不能写元素</span></span><br><span class="line">string::const_iterator it4;         <span class="comment">// it4 只能读字符，不能写字符。</span></span><br></pre></td></tr></table></figure>

<h3 id="begin-和-end-的返回类型"><a href="#begin-和-end-的返回类型" class="headerlink" title="begin 和 end 的返回类型"></a>begin 和 end 的返回类型</h3><p>begin 和 end 返回的具体类型由对象是否是常量决定，如果对象是常量，begin 和 end 返回 const_iterator；如果对象不是常量，返回 iterator：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="type">const</span> vector&lt;<span class="type">int</span>&gt; cv;</span><br><span class="line"><span class="keyword">auto</span> it1 = v.<span class="built_in">begin</span>();       <span class="comment">// it1 的类型是 vector&lt;int&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = cv.<span class="built_in">begin</span>();      <span class="comment">// it2 的类型是 vector&lt;int&gt;::const_iterator</span></span><br></pre></td></tr></table></figure>

<p>如果对象只需读操作而无须写操作的话最好使用常量类型（比如 const_iterator)。可以使用 <strong>cbegin</strong> 和 <strong>cend</strong> 来得到 const_iterator 类型的返回值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">auto</span> it = v.<span class="built_in">cbegin</span>();       <span class="comment">// it 的类型是 vector&lt;int&gt;::const_iterator</span></span><br></pre></td></tr></table></figure>

<h2 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h2><p>反向迭代器是通过 <code>rbegin()</code> 和 <code>rend()</code> 来获取的。<code>rbegin()</code>返回的是<strong>指向尾元素</strong>的反向迭代器，<code>rend()</code>返回的是<strong>指向头元素前一个元素</strong>的反向迭代器。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="/images/%E8%BF%AD%E4%BB%A3%E5%99%A8.assets/clip_image001.png"
                      alt="rend Reverse  past-the4ast element Reversed sequence  rbe in  be in  Reverse iterator stores an iterator to the next  element than the one it actually refers to  Past-the-last element  end "
                ></p>
<p>与一般的迭代器相反，反向迭代器的加法运算是将迭代器前移，减法运算是将迭代器后移。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时vector中的元素：0 1 2 3 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器指向尾元素</span></span><br><span class="line"><span class="keyword">auto</span> itr = v.<span class="built_in">rbegin</span>();</span><br><span class="line">cout &lt;&lt; *itr &lt;&lt; endl;  <span class="comment">// 输出 4</span></span><br><span class="line"></span><br><span class="line">itr += <span class="number">2</span>; <span class="comment">// 迭代器往前移动2个元素</span></span><br><span class="line">cout &lt;&lt; *itr &lt;&lt; endl;  <span class="comment">// 输出 2</span></span><br></pre></td></tr></table></figure>

<p>标准库中，反向迭代器的类型是 <strong>reverse_iterator</strong> 和 <strong>const_reverse_iterator</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::reverse_iterator itr = v.<span class="built_in">rbegin</span>();</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_reverse_iterator itr = v.<span class="built_in">rbegin</span>();</span><br></pre></td></tr></table></figure>

<h2 id="容器操作可能使迭代器失效"><a href="#容器操作可能使迭代器失效" class="headerlink" title="容器操作可能使迭代器失效"></a>容器操作可能使迭代器失效</h2><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p><strong>vector</strong> 在添加一个元素后，如果重新分配了存储空间，则所有指向该容器的迭代器都会失效；如果没有重新分配空间，指向插入位置之前的迭代器仍有效，指向插入位置之后的迭代器都会失效。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> itr1 = v.<span class="built_in">begin</span>() + <span class="number">1</span>;  <span class="comment">// 指向元素1</span></span><br><span class="line"><span class="keyword">auto</span> itr2 = v.<span class="built_in">begin</span>() + <span class="number">3</span>;  <span class="comment">// 指向元素3</span></span><br><span class="line"></span><br><span class="line">v.<span class="built_in">insert</span>(itr1, <span class="number">5</span>); </span><br><span class="line"><span class="comment">// 插入一个元素后，如果没有重新分配存储空间：</span></span><br><span class="line"><span class="comment">// itr1指向新插入的元素5，itr2指向了元素2，itr2失效</span></span><br></pre></td></tr></table></figure>

<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><ul>
<li><p>从一个容器中删除元素后，指向被删除元素的迭代器会失效。</p>
</li>
<li><p>对于 <strong>vector</strong> 容器，指向被删除元素之前元素的迭代器仍有效，指向被删除元素之后的迭代器失效。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>输入输出</title>
    <url>/2022/11/24/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h2 id="进制显示"><a href="#进制显示" class="headerlink" title="进制显示"></a>进制显示</h2><p>第一种写法。使用 <code>setf</code> 和 <code>unsetf</code> 函数。使用 <code>setf</code> 进行格式化设置后，会影响到后面所有的 <code>cout</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此后所有的数值都以十六进制的方式显示</span></span><br><span class="line">cout.<span class="built_in">setf</span>(ios_base::hex, ios_base::basefield);</span><br><span class="line">cout &lt;&lt; <span class="number">0x5789654</span> &lt;&lt; endl;  <span class="comment">// 输出 5789654</span></span><br><span class="line"></span><br><span class="line">cout.<span class="built_in">unsetf</span>(ios_base::hex); <span class="comment">//恢复默认的进制显示</span></span><br><span class="line">cout &lt;&lt; <span class="number">5566</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="number">7788</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="number">9966</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout.<span class="built_in">setf</span>(ios_base::oct, ios_base::basefield);	<span class="comment">// 设置八进制显示</span></span><br><span class="line">cout &lt;&lt; <span class="number">9527</span> &lt;&lt; endl;</span><br><span class="line">cout.<span class="built_in">setf</span>(ios_base::dec, ios_base::basefield);	<span class="comment">// 设置十进制显示</span></span><br><span class="line">cout &lt;&lt; <span class="number">9527</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>另一种写法。这种写法设置了进制格式后，也会对后面所有的 <code>cout</code> 产生影响。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//另一种写法。</span></span><br><span class="line">cout &lt;&lt; std::hex &lt;&lt; <span class="number">0x4455</span> &lt;&lt; std::endl;  <span class="comment">// 十六进制输出 4455</span></span><br><span class="line">cout &lt;&lt; <span class="number">0x1234</span>;  <span class="comment">// 十六进制输出 1234</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; std::oct &lt;&lt; <span class="number">9527</span> &lt;&lt; std::endl;  <span class="comment">// 八进制输出</span></span><br><span class="line">cout &lt;&lt; <span class="number">5566</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; std::dec &lt;&lt; <span class="number">66666</span> &lt;&lt; <span class="string">&quot; &quot;</span>  <span class="comment">// 十进制输出</span></span><br><span class="line">    &lt;&lt; <span class="number">7777</span> &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">    &lt;&lt; endl;</span><br></pre></td></tr></table></figure>



<h2 id="浮点显示"><a href="#浮点显示" class="headerlink" title="浮点显示"></a>浮点显示</h2><h3 id="定点小数和科学计数法"><a href="#定点小数和科学计数法" class="headerlink" title="定点小数和科学计数法"></a>定点小数和科学计数法</h3><p>与上面的进制输出一样，使用这种方式输出，将会影响后面所有的 <code>cout</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.2154 定点</span></span><br><span class="line"><span class="comment">// 3.21 X 10 ^2 = 321 科学计数法</span></span><br><span class="line">cout &lt;&lt; <span class="number">13.6958</span> &lt;&lt; endl;  <span class="comment">// 使用默认的顶点小数输出，输出：13.6958</span></span><br><span class="line">cout &lt;&lt; std::fixed &lt;&lt; <span class="number">13.6958</span> &lt;&lt; endl; <span class="comment">// 定点小数，输出：13.695800</span></span><br><span class="line">cout &lt;&lt; std::scientific &lt;&lt; <span class="number">13.6958</span> &lt;&lt; endl;<span class="comment">//科学计数法，输出：1.369580e+01</span></span><br><span class="line">cout &lt;&lt; std::scientific &lt;&lt; <span class="number">0.000136958</span> &lt;&lt; endl;<span class="comment">//科学计数法，输出：1.369580e-04</span></span><br><span class="line"></span><br><span class="line">cout.<span class="built_in">unsetf</span>(ios_base::scientific); <span class="comment">//取消科学计数法,恢复默认的定点法</span></span><br></pre></td></tr></table></figure>

<h3 id="设置精度"><a href="#设置精度" class="headerlink" title="设置精度"></a>设置精度</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span>.precision(<span class="number">3</span>); <span class="comment">//精度设为3</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::fixed &lt;&lt; <span class="number">13.6958</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出：13.696</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::scientific &lt;&lt; <span class="number">13.6958</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出：1.370e+01</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>.unsetf(ios_base::scientific);  <span class="comment">//取消科学计数法,恢复默认的定点法</span></span><br><span class="line"><span class="built_in">cout</span>.precision(<span class="number">4</span>);  <span class="comment">//对于默认的定点计数, precision为输出的有效位,包括小数点前和小数点后</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">536.78545665</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出：536.8</span></span><br><span class="line"><span class="built_in">cout</span>.precision(<span class="number">6</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">5556.4544454</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出：5556.45</span></span><br></pre></td></tr></table></figure>

<p>当使用 <code>fixed</code> 和 <code>scientific</code> 时，<code>precision</code> 函数是设置显示的小数位数。</p>
<p>当使用默认的顶点计数法时，<code>precision</code> 函数是设置显示多少有效位，而不是小数位数。</p>
<h2 id="输出对齐"><a href="#输出对齐" class="headerlink" title="输出对齐"></a>输出对齐</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout.<span class="built_in">width</span>(<span class="number">10</span>);	<span class="comment">// 设置需要对齐的范围</span></span><br><span class="line">cout &lt;&lt; std::right &lt;&lt; <span class="string">&quot;world&quot;</span> &lt;&lt; std::endl;	<span class="comment">// 右对齐，输出：&quot;     world&quot;</span></span><br><span class="line"></span><br><span class="line">cout.<span class="built_in">width</span>(<span class="number">10</span>);</span><br><span class="line">cout.<span class="built_in">fill</span>(<span class="string">&#x27;$&#x27;</span>);	<span class="comment">// 设置用来填充的字符</span></span><br><span class="line">cout &lt;&lt; std::internal &lt;&lt; <span class="number">-12.23</span> &lt;&lt; endl; <span class="comment">//填充到符号和数值之间，输出：&quot;-$$$$12.23&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="显示进制前缀"><a href="#显示进制前缀" class="headerlink" title="显示进制前缀"></a>显示进制前缀</h2><p><code>showbase</code> 用来在显示进制时加上前缀。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; std::showbase &lt;&lt; std::hex &lt;&lt; <span class="number">0x5566</span> &lt;&lt; endl;	<span class="comment">// 输出0x5566，加上了前缀0x</span></span><br><span class="line">cout &lt;&lt; std::showbase &lt;&lt; std::dec &lt;&lt; <span class="number">5566</span> &lt;&lt; endl;		<span class="comment">// 输出5566</span></span><br><span class="line">cout &lt;&lt; std::showbase &lt;&lt; std::oct &lt;&lt; <span class="number">5566</span> &lt;&lt; endl;		<span class="comment">// 输出012676，加上了前缀0</span></span><br></pre></td></tr></table></figure>



<h2 id="处理-cin-的输入错误"><a href="#处理-cin-的输入错误" class="headerlink" title="处理 cin 的输入错误"></a>处理 cin 的输入错误</h2><p>如果使用 <code>cin</code> 进行输入时出现错误，那么 <code>cin</code> 就会一直处于错误状态，导致后面的所有 <code>cin</code> 都无法进行输入操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;n is &quot;</span> &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">666</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码如果在输入时输入一些字符，比如 “hh”，就会导致程序进入死循环，一直在打印信息，却无法进行输入。这是因为，为整型变量 n 输入其他字符导致 <code>cin</code> 出错，<code>cin</code> 将自己的状态标志设置为 fail。下一次循环执行 <code>std::cin &gt;&gt; n</code> 时，由于状态标志是 fail，<code>cin</code> 就不会进行输入操作。因此程序就跳过了输入，一直在执行输出，导致陷入死循环。</p>
<p>为了避免死循环问题，可以使用下面这些函数：</p>
<ul>
<li><code>cin.fail()</code>：检测 <code>cin</code> 的状态标志。</li>
<li><code>cin.clear()</code>：清除错误状态。</li>
<li><code>cin.ignore()</code>：删除缓冲区中的内容。该函数可以设置要删除的字符数，也可以设置遇到某个字符就停止删除。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span> (std::cin.<span class="built_in">fail</span>())	<span class="comment">// cin.fail(): 判断cin是否处于fail状态</span></span><br><span class="line">    &#123;</span><br><span class="line">        cin.<span class="built_in">clear</span>();	<span class="comment">// cin.clear(): 清除cin的错误状态</span></span><br><span class="line">        <span class="type">int</span> nCntAvail = cin.<span class="built_in">rdbuf</span>()-&gt;<span class="built_in">in_avail</span>();	<span class="comment">// 取得缓冲区中还剩下的字符数</span></span><br><span class="line">        cin.<span class="built_in">ignore</span>(nCntAvail);  <span class="comment">// cin.ignore(): 忽略缓冲区中的内容</span></span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;输入错误，请重新输入&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;n is &quot;</span> &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">666</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符重载</title>
    <url>/2022/11/24/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><p>目的：提高代码的可读性和提高类的易用性。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul>
<li><p>重载的运算符是带有特殊名称的函数，函数名是由关键字<code>operator</code>和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CInteger</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetData</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; m_nData = n; &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetData</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_nData; &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 返回类型 operator运算符(参数列表) &#123; 函数体 &#125;</span></span><br><span class="line">    <span class="comment">// 对加号进行运算符重载</span></span><br><span class="line">	<span class="type">int</span> <span class="keyword">operator</span>+(<span class="type">int</span> n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> m_nData + n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CInteger n;</span><br><span class="line">	n.<span class="built_in">SetData</span>(<span class="number">66</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 使用重载的运算符</span></span><br><span class="line">	<span class="type">int</span> nRet1 = n + <span class="number">88</span>; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运算符重载可以定义成类成员，也可以定义在类外。在类外定义的话，就是全局的运算符重载，这种情况一般将其写成类的友元。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CInteger</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetData</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; m_nData = n; &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetData</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_nData; &#125;</span><br><span class="line">	<span class="comment">// 一般将全局的运算符重载写成友元函数。</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">int</span> <span class="keyword">operator</span>+(<span class="type">const</span> CInteger&amp; cn, <span class="type">int</span> n);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义在类外运算符重载。</span></span><br><span class="line"><span class="comment">// 在进行加法操作时需要一左一右两个操作数，所以函数的参数有两个。</span></span><br><span class="line"><span class="comment">// 定义在类的内部时，因为有默认的this指针参数，所以参数列表中只需再定义一个参数即可。</span></span><br><span class="line"><span class="type">int</span> <span class="keyword">operator</span>+(<span class="type">const</span> CInteger&amp; cn, <span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> cn.m_nData + n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CInteger n;</span><br><span class="line">	n.<span class="built_in">SetData</span>(<span class="number">66</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> nRet1 = n + <span class="number">88</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果将运算符重载定义成类成员，那么完全可以通过调用成员函数的方式来进行调用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CInteger</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetData</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; m_nData = n; &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetData</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_nData; &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 对加号进行运算符重载</span></span><br><span class="line">	<span class="type">int</span> <span class="keyword">operator</span>+(<span class="type">int</span> n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> m_nData + n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CInteger n;</span><br><span class="line">	n.<span class="built_in">SetData</span>(<span class="number">66</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 下面两种使用方式是完全等价</span></span><br><span class="line">	<span class="type">int</span> nRet1 = n + <span class="number">88</span>; </span><br><span class="line">	<span class="type">int</span> nRet2 = n.<span class="keyword">operator</span>+(<span class="number">88</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从下面的汇编代码可以看出，两种使用方式是完全等价的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">	<span class="type">int</span> nRet1 = n + <span class="number">88</span>;</span><br><span class="line"><span class="number">00411</span>AF2  push        <span class="number">58</span>h  </span><br><span class="line"><span class="number">00411</span>AF4  lea         ecx,[n]  </span><br><span class="line"><span class="number">00411</span><span class="function">AF7  call        <span class="title">A::A</span> <span class="params">(<span class="number">041140B</span>h)</span>  </span></span><br><span class="line"><span class="function">00411AFC  mov         dword ptr [nRet1],eax  </span></span><br><span class="line"><span class="function">	<span class="type">int</span> nRet2 </span>= n.<span class="keyword">operator</span>+(<span class="number">88</span>);</span><br><span class="line"><span class="number">00411</span>AFF  push        <span class="number">58</span>h  </span><br><span class="line"><span class="number">00411B</span>01  lea         ecx,[n]  </span><br><span class="line"><span class="number">00411B</span>04  <span class="function">call        <span class="title">A::A</span> <span class="params">(<span class="number">041140B</span>h)</span>  </span></span><br><span class="line"><span class="function">00411B09  mov         dword ptr [nRet2],eax</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="运算符重载的原则"><a href="#运算符重载的原则" class="headerlink" title="运算符重载的原则"></a>运算符重载的原则</h2><ul>
<li><p>运算符重载不能改变运算符原有的使用方式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CInteger</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetData</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; m_nData = n; &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetData</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_nData; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义在类外的运算符重载。</span></span><br><span class="line"><span class="comment">// 加法运算只需要两个操作数，这里定义了三个，改变了原有的使用方式。</span></span><br><span class="line"><span class="type">int</span> <span class="keyword">operator</span>+(<span class="type">const</span> CInteger&amp; cn, <span class="type">int</span> n， <span class="type">int</span> x)  <span class="comment">// 报错</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> cn.<span class="built_in">GetData</span>() + n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>运算符重载不能改变原有运算符的意义。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CInteger</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetData</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; m_nData = n; &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetData</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_nData; &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 返回类型 operator运算符(参数列表) &#123; 函数体 &#125;</span></span><br><span class="line">    <span class="comment">// 对加号进行运算符重载</span></span><br><span class="line">	<span class="type">int</span> <span class="keyword">operator</span>+(<span class="type">int</span> n)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 加号本来是进行加法的，结果这里写成减法。改变了运算符原有的意义。</span></span><br><span class="line">        <span class="comment">// 虽然语法上没有错，但是不应该这么写。</span></span><br><span class="line">		<span class="keyword">return</span> m_nData - n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><ul>
<li><p>如果没有实现赋值运算符重载，编译器会提供一个默认的赋值运算符重载。默认的赋值运算符重载是直接进行浅拷贝。</p>
</li>
<li><p>重载赋值运算符时，一般是返回<code>*this</code>，也就是当前类的引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CTest&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CTest&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做的好处：</p>
<ul>
<li>在函数返回时避免一次拷贝，提高了效率。</li>
<li>可以支持链式调用。</li>
</ul>
</li>
<li><p>重载赋值运算符时，函数的返回值类型可以是<code>void</code>。因为在单独的赋值语句时，<code>a = b;</code>，并不会用到返回值。但是在连续赋值时，<code>a = b = c;</code>，<code>b=c</code>的返回值会作为下次赋值的参数，这种情况下返回值类型就不能是<code>void</code>。</p>
</li>
<li><p>对象初始化时，<code>CTest a = b;</code>，执行的是拷贝构造函数，而不是赋值运算符。</p>
</li>
</ul>
<p>阅读材料：<a class="link"   href="https://www.cnblogs.com/zpcdbky/p/5027481.html" >一文说尽C++赋值运算符重载函数(operator&#x3D;)<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>算术运算符很多，下面是其中的一些：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">+ - * / % -- ++ += -= *= /= %=</span><br></pre></td></tr></table></figure>

<p>对运算符重载时，要根据这些运算符原本的使用方式来进行重载。</p>
<h3 id="加法运算符"><a href="#加法运算符" class="headerlink" title="+ 加法运算符"></a>+ 加法运算符</h3><p>常规做法是只实现一个重载来应对不同的情况。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CInteger</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CInteger</span>(<span class="type">int</span> n) :<span class="built_in">m_nData</span>(n) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetData</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; m_nData = n; &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetData</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_nData; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> CInteger <span class="keyword">operator</span>+(<span class="type">const</span> CInteger&amp; obj1, <span class="type">const</span> CInteger&amp; obj2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用编译器的隐式转换和构造函数，只用实现这一个+运算符的重载就可以应对不同的情况。</span></span><br><span class="line">CInteger <span class="keyword">operator</span>+(<span class="type">const</span> CInteger&amp; obj1, <span class="type">const</span> CInteger&amp; obj2)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">CInteger</span>(obj1.m_nData + obj2.m_nData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">CInteger <span class="title">n</span><span class="params">(<span class="number">15</span>)</span></span>;</span><br><span class="line">	n + <span class="number">10</span>;  <span class="comment">// 隐式转换，相当于 n + CInteger(10);</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运算符"><a href="#运算符" class="headerlink" title="++运算符"></a>++运算符</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CInteger</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CInteger</span>(<span class="type">int</span> n) :<span class="built_in">m_nData</span>(n) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetData</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; m_nData = n; &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetData</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_nData; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对前++进行重载</span></span><br><span class="line">	<span class="comment">// 根据前++的使用方式，一般返回引用。</span></span><br><span class="line">	CInteger&amp; <span class="keyword">operator</span>++()</span><br><span class="line">	&#123;</span><br><span class="line">		++m_nData;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对后++进行重载。为了区分前后++，规定在重载后++时，参数列表中写一个int</span></span><br><span class="line">	<span class="comment">// 根据后++的使用方式，一般返回对象</span></span><br><span class="line">	CInteger <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> nOld = m_nData;</span><br><span class="line">		++m_nData;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">CInteger</span>(nOld);  <span class="comment">// 后++返回旧值</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="关系（逻辑）运算符"><a href="#关系（逻辑）运算符" class="headerlink" title="关系（逻辑）运算符"></a>关系（逻辑）运算符</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&amp;&amp;  ||  ! </span><br><span class="line">==  !=  &gt;=  &lt;=  &lt;  &gt;</span><br></pre></td></tr></table></figure>

<p>例子:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CInteger</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CInteger</span>(<span class="type">int</span> n) :<span class="built_in">m_nData</span>(n) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重载==运算符</span></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">int</span> n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> m_nData == n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 重载!=运算符</span></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">int</span> n)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 直接判断对==的结果取反就行，重用了bool operator==(int n)函数</span></span><br><span class="line">		<span class="keyword">return</span> !(*<span class="keyword">this</span> == n);  <span class="comment">// 代码重用，此处会调用==运算符的重载</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="输入输出运算符"><a href="#输入输出运算符" class="headerlink" title="输入输出运算符"></a>输入输出运算符</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CInteger</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CInteger</span>(<span class="type">int</span> n) :<span class="built_in">m_nData</span>(n) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重载输出运算符。</span></span><br><span class="line">	<span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> CInteger&amp; cn);</span><br><span class="line">	<span class="comment">// 重载输入运算符</span></span><br><span class="line">	<span class="keyword">friend</span> std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; is, CInteger&amp; cn);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载输出运算符。</span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> CInteger&amp; cn)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; cn.m_nData;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重载输入运算符</span></span><br><span class="line">std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; is, CInteger&amp; cn)</span><br><span class="line">&#123;</span><br><span class="line">	is &gt;&gt; cn.m_nData;</span><br><span class="line">	<span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">CInteger <span class="title">cn</span><span class="params">(<span class="number">15</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; cn &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="new-和-delete"><a href="#new-和-delete" class="headerlink" title="new 和 delete"></a>new 和 delete</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CInteger</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CInteger</span>(<span class="type">int</span> n1, <span class="type">int</span> n2) :<span class="built_in">m_nData1</span>(n1), <span class="built_in">m_nData2</span>(n2) &#123;&#125;</span><br><span class="line">	~<span class="built_in">CInteger</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重载new运算符</span></span><br><span class="line">	<span class="comment">// 返回值必须为void*。参数是要申请的内存大小，在使用时编译器自动计算所需大小并传入。</span></span><br><span class="line">	<span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> nb)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">malloc</span>(nb);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重载delete运算符</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">free</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nData1;</span><br><span class="line">	<span class="type">int</span> m_nData2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 调用重载后的new运算符，编译器自动计算所需的大小</span></span><br><span class="line">	<span class="comment">// 在执行完重载的new后，编译器会自动调用类的构造函数。</span></span><br><span class="line">	CInteger* p = <span class="keyword">new</span> <span class="built_in">CInteger</span>(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 编译器会自动调用析构函数，析构完后，再调用重载的delete运算符</span></span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="类型转换运算符"><a href="#类型转换运算符" class="headerlink" title="类型转换运算符"></a>类型转换运算符</h2><p>如果一个类对多个类型转换运算符进行了重载，在使用时就有可能出现二义性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CInteger</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CInteger</span>(<span class="type">int</span> n) :<span class="built_in">m_nData</span>(n) &#123;&#125;</span><br><span class="line">	~<span class="built_in">CInteger</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重载类型强制转换运算符</span></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_nData;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 重载类型强制转换运算符</span></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_nData;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_nData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">CInteger <span class="title">cn</span><span class="params">(<span class="number">15</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 编译器会调用重载的类型转换运算符来进行类型转换。</span></span><br><span class="line">	<span class="type">int</span> n1 = <span class="number">50</span> + (<span class="type">int</span>)cn;  <span class="comment">// 相当于 50 + cn.operator int();</span></span><br><span class="line">	<span class="type">double</span> dbl1 = <span class="number">50</span> + (<span class="type">double</span>)cn; <span class="comment">// 相当于 50 + cn.operator double();</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> n2 = <span class="number">50</span> + cn;  <span class="comment">// 报错，重载了多个类型转换运算符，编译器不知道要用哪个。</span></span><br><span class="line">    <span class="comment">// 如果只重载了一个operator int()的话，那么上面这行代码就是正确的，</span></span><br><span class="line">    <span class="comment">// 编译器会自动调用operator int()进行转换。</span></span><br><span class="line">    <span class="comment">// 现在重载了两个，编译器就不知道要调用哪一个进行转换了。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="运算符-1"><a href="#运算符-1" class="headerlink" title="() 运算符"></a>() 运算符</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyString</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CMyString</span>(<span class="type">const</span> <span class="type">char</span>* psz)</span><br><span class="line">	&#123;</span><br><span class="line">		m_psz = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(psz) + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">strcpy</span>(m_psz, psz);</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">CMyString</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_psz != <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span>[] m_psz;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重载()运算符</span></span><br><span class="line">	<span class="function"><span class="type">char</span>* <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_psz;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span>* m_psz = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">CMyString <span class="title">str</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="运算符-2"><a href="#运算符-2" class="headerlink" title="[] 运算符"></a>[] 运算符</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CMyString</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CMyString</span>(<span class="type">const</span> <span class="type">char</span>* psz)</span><br><span class="line">	&#123;</span><br><span class="line">		m_psz = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(psz) + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">strcpy</span>(m_psz, psz);</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">CMyString</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_psz != <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span>[] m_psz;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重载[]运算符</span></span><br><span class="line">	<span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> uIndex)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 注意检查索引是否越界，assert()</span></span><br><span class="line">		<span class="comment">// 这里没有检查</span></span><br><span class="line">		<span class="keyword">return</span> m_psz[uIndex];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span>* m_psz = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">CMyString <span class="title">str</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	str[<span class="number">1</span>] = <span class="string">&#x27;E&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="编程经验"><a href="#编程经验" class="headerlink" title="编程经验"></a>编程经验</h2><p>在实现类的时候，最好自己实现默认构造，拷贝构造和赋值运算符重载，不要使用编译器默认生成的。因为编译器的拷贝构造和赋值运算符重载都是进行浅拷贝的。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>预处理处理</title>
    <url>/2022/11/25/%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p><code>#</code>开头的语句表示编译预处理指令。</p>
<h2 id="include"><a href="#include" class="headerlink" title="#include"></a>#include</h2><ol>
<li><code>#include</code>是文件包含指令。该指令的作用是在编译前将所包含的文件内容复制到该行处。该指令可以使用 <code>&lt;&gt;</code> 和 <code>&quot;&quot;</code> 两种符号，区别如下：</li>
</ol>
<ul>
<li><p><code>&lt;&gt;</code>：从环境变量 <code>include</code> 中存在的路径寻找。不会在源码所在的目录进行寻找。</p>
</li>
<li><p><code>&quot;&quot;</code>：先从源码所在的目录进行寻找，没找到的话再去环境变量 <code>include</code> 中寻找。</p>
</li>
</ul>
<ol start="2">
<li><p><strong>代码规范</strong>：包含标准库文件时使用尖括号，包含自己写的头文件时使用双引号。</p>
</li>
<li><p><code>#include</code>指令的本质就是复制粘贴，在包含文件时并不关注文件本身的类型。不管是什么类型的文件，<code>#include</code>指令都会以文本形式对其进行包含。</p>
</li>
</ol>
<h2 id="pragma-pack"><a href="#pragma-pack" class="headerlink" title="#pragma pack"></a>#pragma pack</h2><ul>
<li><code>#pragma pack(show)</code>：显示当前packing alignment的字节数，以warning message的形式被显示。</li>
<li><code>#pragma pack(push)</code>：将当前的对齐值保存到栈上，这里的栈指的是 the internal compiler stack。</li>
<li><code>#pragma pack(pop)</code>：从 the internal compiler stack 中弹出栈顶，并作为新的对齐值。</li>
<li><code>#pragma pack(n)</code>：设置对齐值，程序默认的对齐值是 8。合法的数值分别是 1，2，4，8，16。</li>
</ul>
<h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IS_DEBUG 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>	IS_DEBUG	<span class="comment">// 根据IS_DEBUG是否为真来选择参与编译的部分</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IS_DEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> IS_DEBUG	<span class="comment">// 只看IS_DEBUG是否定义，不关心它的值</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> IS_DEBUG <span class="comment">// 只看IS_DEBUG是否定义，不关心它的值</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(IS_DEBUG)	<span class="comment">// 等价于 #ifdef IS_DEBUG</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(IS_DEBUG)	<span class="comment">// 等价于 #ifndef IS_DEBUG</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h3 id="防止头文件重复包含"><a href="#防止头文件重复包含" class="headerlink" title="防止头文件重复包含"></a>防止头文件重复包含</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifndef MYLIB_H_GUID</span><br><span class="line">#define MYLIB_H_GUID</span><br><span class="line">...</span><br><span class="line">#endif </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
</search>
